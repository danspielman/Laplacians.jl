<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>solvers · Laplacians.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Laplacians.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">About</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../Installation/">Installation</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../CSCgraph/">Sparse matrices as graphs</a></li><li><a class="tocitem" href="../usingSolvers/">Solving Linear Equations</a></li><li><a class="tocitem" href="../LSST/">Low Stretch Spanning Trees</a></li></ul></li><li><a class="tocitem" href="../Developing/">Developing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../graphGenerators/">generators</a></li><li><a class="tocitem" href="../operators/">operators</a></li><li><a class="tocitem" href="../graphUtils/">graphUtils</a></li><li><a class="tocitem" href="../graphAlgs/">graphAlgs</a></li><li><a class="tocitem" href="../IO/">IO</a></li><li class="is-active"><a class="tocitem" href>solvers</a></li><li><a class="tocitem" href="../sparsification/">sparsification</a></li><li><a class="tocitem" href="../akpw/">akpw</a></li><li><a class="tocitem" href="../treeAlgs/">treeAlgs</a></li><li><a class="tocitem" href="../randTrees/">randTrees</a></li><li><a class="tocitem" href="../localClustering/">localClustering</a></li><li><a class="tocitem" href="../privateFuncs/">Private Functions</a></li><li><a class="tocitem" href="../indexOfAll/">All of the above</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/danspielman/Laplacians.jl/blob/master/docs/src/solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-Equation-Solvers-1"><a class="docs-heading-anchor" href="#Linear-Equation-Solvers-1">Linear Equation Solvers</a><a class="docs-heading-anchor-permalink" href="#Linear-Equation-Solvers-1" title="Permalink"></a></h1><p>For more, see the page <a href="../usingSolvers/">on using solvers</a>.</p><ul><li><a href="#Laplacians.KMPParams"><code>Laplacians.KMPParams</code></a></li><li><a href="#Laplacians.KMPLapSolver-Tuple{Any}"><code>Laplacians.KMPLapSolver</code></a></li><li><a href="#Laplacians.KMPSDDMSolver-Tuple{Any}"><code>Laplacians.KMPSDDMSolver</code></a></li><li><a href="#Laplacians.approxchol_lap-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.approxchol_lap</code></a></li><li><a href="#Laplacians.approxchol_lap2-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.approxchol_lap2</code></a></li><li><a href="#Laplacians.approxchol_sddm"><code>Laplacians.approxchol_sddm</code></a></li><li><a href="#Laplacians.augTreeLap-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.augTreeLap</code></a></li><li><a href="#Laplacians.augTreeLapPrecon-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.augTreeLapPrecon</code></a></li><li><a href="#Laplacians.augTreePrecon-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.augTreePrecon</code></a></li><li><a href="#Laplacians.augTreeSddm-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.augTreeSddm</code></a></li><li><a href="#Laplacians.augmentTree-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}, Ti}} where {Tv, Ti}"><code>Laplacians.augmentTree</code></a></li><li><a href="#Laplacians.cg"><code>Laplacians.cg</code></a></li><li><a href="#Laplacians.cgLapSolver-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.cgLapSolver</code></a></li><li><a href="#Laplacians.cgSolver"><code>Laplacians.cgSolver</code></a></li><li><a href="#Laplacians.chol_lap"><code>Laplacians.chol_lap</code></a></li><li><a href="#Laplacians.chol_sddm"><code>Laplacians.chol_sddm</code></a></li><li><a href="#Laplacians.condNumber-Tuple{Any, Any}"><code>Laplacians.condNumber</code></a></li><li><a href="#Laplacians.harmonic_interp-Tuple{Any, Vector, Vector}"><code>Laplacians.harmonic_interp</code></a></li><li><a href="#Laplacians.lapWrapSDDM-Tuple{Any, AbstractArray}"><code>Laplacians.lapWrapSDDM</code></a></li><li><a href="#Laplacians.pcg"><code>Laplacians.pcg</code></a></li><li><a href="#Laplacians.pcgLapSolver-Tuple{AbstractMatrix, AbstractMatrix}"><code>Laplacians.pcgLapSolver</code></a></li><li><a href="#Laplacians.pcgSolver"><code>Laplacians.pcgSolver</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Laplacians.chol_lap" href="#Laplacians.chol_lap"><code>Laplacians.chol_lap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solver = chol_lap(A::AbstractArray)</code></pre><p>Uses Cholesky Factorization to solve systems in Laplacians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/solverInterface.jl#L310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.chol_sddm" href="#Laplacians.chol_sddm"><code>Laplacians.chol_sddm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solveSDDM = chol_sddm(sddm::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[])</code></pre><p>This functions wraps cholfact so that it satsfies our interface. It ignores all the keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/solverInterface.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.lapWrapSDDM-Tuple{Any, AbstractArray}" href="#Laplacians.lapWrapSDDM-Tuple{Any, AbstractArray}"><code>Laplacians.lapWrapSDDM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = lapWrapSDDM(sddmSolver, A::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)
f = lapWrapSDDM(sddmSolver)</code></pre><p>Uses a <code>sddmSolver</code> to solve systems of linear equations in Laplacian matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/solverInterface.jl#L285-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.cg" href="#Laplacians.cg"><code>Laplacians.cg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = cg(mat, b; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>solves a symmetric linear system <code>mat x = b</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tol</code> is set to 1e-6 by default,</li><li><code>maxits</code> defaults to Inf</li><li><code>maxtime</code> defaults to Inf.  It measures seconds.</li><li><code>verbose</code> defaults to false</li><li><code>pcgIts</code> is an array for returning the number of pcgIterations.  Default is length 0, in which case nothing is returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/pcg.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.cgLapSolver-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.cgLapSolver-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.cgLapSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x = cgLapSolver(A::AbstractMatrix; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[])</code></pre><p>Create a solver that uses cg to solve Laplacian systems in the laplacian of A. This just exists to satisfy our interface. It does nothing more than create the Laplacian and call cg on each connected component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/pcg.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.cgSolver" href="#Laplacians.cgSolver"><code>Laplacians.cgSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = cgSolver(mat; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>creates a solver for a PSD system <code>mat</code>. The parameters are as described in cg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/pcg.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.pcg" href="#Laplacians.pcg"><code>Laplacians.pcg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = pcg(mat, b, pre; tol, maxits, maxtime, verbose, pcgIts, stag_test)`</code></pre><p>solves a symmetric linear system using preconditioner <code>pre</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pre</code> can be a function or a matrix.  If a matrix, a function to solve it is created with cholFact.</li><li><code>tol</code> is set to 1e-6 by default,</li><li><code>maxits</code> defaults to Inf</li><li><code>maxtime</code> defaults to Inf.  It measures seconds.</li><li><code>verbose</code> defaults to false</li><li><code>pcgIts</code> is an array for returning the number of pcgIterations.  Default is length 0, in which case nothing is returned.</li><li><code>stag_test=k</code> stops the code if rho[it] &gt; (1-1/k) rho[it-k].  Set to 0 to deactivate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/pcg.jl#L26-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.pcgLapSolver-Tuple{AbstractMatrix, AbstractMatrix}" href="#Laplacians.pcgLapSolver-Tuple{AbstractMatrix, AbstractMatrix}"><code>Laplacians.pcgLapSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x = pcgLapSolver(A, B; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[])</code></pre><p>Create a solver that uses pcg to solve Laplacian systems in <code>A</code> Specialized for the case when the preconditioner the Laplacian matrix of <code>B</code>. It solves the preconditioner by Cholesky Factorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/pcg.jl#L124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.pcgSolver" href="#Laplacians.pcgSolver"><code>Laplacians.pcgSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = pcgSolver(mat, pre; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>creates a solver for a PSD system using preconditioner <code>pre</code>. The parameters are as described in pcg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/pcg.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.approxchol_lap-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.approxchol_lap-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.approxchol_lap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solver = approxchol_lap(a); x = solver(b);
solver = approxchol_lap(a; tol::Real=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())</code></pre><p>A heuristic solver by Yuan Gao, Rasmus Kyng, and Daniel Spielman, see paper https://arxiv.org/abs/2303.00709. The solver is inspired by the solver in https://arxiv.org/abs/1605.02353 by Rasmus Kyng and Sushant Sachdeva. Whereas that paper eliminates vertices one at a time, this eliminates edges one at a time.  It is probably possible to analyze it. The <code>ApproxCholParams</code> let you choose one of three orderings to perform the elimination.</p><ul><li>ApproxCholParams(:given) - in the order given.   This is the fastest for construction the preconditioner, but the slowest solve.</li><li>ApproxCholParams(:deg) - always eliminate the node of lowest degree.   This is the slowest build, but the fastest solve.</li><li>ApproxCholParams(:wdeg) - go by a perturbed order of wted degree.</li></ul><p>For more info, see http://danspielman.github.io/Laplacians.jl/dev/usingSolvers/index.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/approxChol.jl#L1507-L1521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.approxchol_lap2-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.approxchol_lap2-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.approxchol_lap2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solver = approxchol_lap2(a); x = solver(b);
solver = approxchol_lap2(a; tol::Real=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())</code></pre><p><code>approxchol_lap2</code> is slower than <code>approxchol_lap</code> (by roughly a factor 2), but is more robust.</p><p>A heuristic solver by Yuan Gao, Rasmus Kyng, and Daniel Spielman, see paper https://arxiv.org/abs/2303.00709. The solver is inspired by the solver in https://arxiv.org/abs/1605.02353 by Rasmus Kyng and Sushant Sachdeva. Whereas that paper eliminates vertices one at a time, this eliminates edges one at a time.  It is probably possible to analyze it.</p><p><code>approxchol_lap2</code> only implements the ordering given by ApproxCholParams(:deg) - always eliminate the node of lowest degree.</p><p>For more info, see http://danspielman.github.io/Laplacians.jl/dev/usingSolvers/index.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/approxChol.jl#L1547-L1558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.approxchol_sddm" href="#Laplacians.approxchol_sddm"><code>Laplacians.approxchol_sddm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solver = approxchol_sddm(sddm); x = solver(b);
solver = approxchol_sddm(sddm; tol=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())</code></pre><p>Solves sddm systems by wrapping approxchol_lap. Not yet optimized directly for sddm.</p><p>For more info, see http://danspielman.github.io/Laplacians.jl/latest/usingSolvers/index.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/approxChol.jl#L1853-L1861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.condNumber-Tuple{Any, Any}" href="#Laplacians.condNumber-Tuple{Any, Any}"><code>Laplacians.condNumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cn = condNumber(a, ldli; verbose=false)</code></pre><p>Given an adjacency matrix a and an ldli computed by approxChol, this computes the condition number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/approxChol.jl#L1874-L1879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.augTreeLap-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.augTreeLap-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.augTreeLap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solver = augTreeLap(A; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params=AugTreeParams())</code></pre><p>An &quot;augmented spanning tree&quot; solver for Laplacians.  It works by adding edges to a low stretch spanning tree.  It calls <code>augTreePrecon</code> to form the preconditioner.  <code>params</code> has entries</p><ul><li><code>params.treeAlg</code> default to <code>akpw</code></li><li><code>params.opt</code> if true, it interacts with cholmod to choose a good number of edges to add back.  If false, it adds back 2*sqrt(n).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/augTreeSolver.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.augTreeLapPrecon-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.augTreeLapPrecon-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.augTreeLapPrecon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pre = augTreeLapPrecon{Tv,Ti}(A; params=AugTreeParams())</code></pre><p>This is an augmented spanning tree preconditioner for Laplacians. It takes as optional input a tree growing algorithm. It adds back 2sqrt(n) edges via <code>augmentTree</code>: the sqrt(n) of highest stretch and another sqrt(n) sampled according to stretch. For most purposes, one should directly call <code>augTreeLapSolver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/augTreeSolver.jl#L252-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.augTreePrecon-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.augTreePrecon-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.augTreePrecon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pre = augTreePrecon{Tv,Ti}(ddmat::SparseMatrixCSC{Tv,Ti}; params=AugTreeParams())</code></pre><p>This is an augmented spanning tree preconditioner for diagonally dominant linear systems.  It takes as optional input a tree growing algorithm. It adds back 2sqrt(n) edges via augmentTree: the sqrt(n) of highest stretch and another sqrt(n) sampled according to stretch. For most purposes, one should directly call <code>augTreeSolver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/augTreeSolver.jl#L187-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.augTreeSddm-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.augTreeSddm-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.augTreeSddm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solver = augTreeSddm(sddm; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[],  params=AugTreeParams())</code></pre><p>An &quot;augmented spanning tree&quot; solver for positive definite diagonally dominant matrices.  It works by adding edges to a low stretch spanning tree.  It calls <code>augTreePrecon</code> to form the preconditioner.  <code>params</code> has entries</p><ul><li><code>params.treeAlg</code> default to <code>akpw</code></li><li><code>params.opt</code> if true, it interacts with cholmod to choose a good number of edges to add back.  If false, it adds back 2*sqrt(n).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/augTreeSolver.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.augmentTree-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}, Ti}} where {Tv, Ti}" href="#Laplacians.augmentTree-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}, Ti}} where {Tv, Ti}"><code>Laplacians.augmentTree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">B = augmentTree{Tv,Ti}(tree, A, k)</code></pre><p>Takes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It then adds back the k edges of highest stretch, and k edges sampled according to stretch.</p><p>This is the old alg.  We now recommend using augmentTreeOpt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/augTreeSolver.jl#L30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.KMPParams" href="#Laplacians.KMPParams"><code>Laplacians.KMPParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parameters for the KMP solver</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/KMPSolver.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.KMPLapSolver-Tuple{Any}" href="#Laplacians.KMPLapSolver-Tuple{Any}"><code>Laplacians.KMPLapSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lapSolver = KMPLapSolver(A; verbose, tol, maxits, maxtime, pcgIts, params::KMPParams)</code></pre><p>Solves linear equations in the Laplacian of graph with adjacency matrix <code>A</code>.</p><p>Based on the paper &quot;Approaching optimality for solving SDD systems&quot; by Koutis, Miller, and Peng, &lt;i&gt;SIAM Journal on Computing&lt;/i&gt;, 2014.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/KMPSolver.jl#L235-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.KMPSDDMSolver-Tuple{Any}" href="#Laplacians.KMPSDDMSolver-Tuple{Any}"><code>Laplacians.KMPSDDMSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sddmSolver = KMPSDDMSolver(mat; verbose, tol, maxits, maxtime, pcgIts, params::KMPParams)</code></pre><p>Solves linear equations in symmetric, diagonally dominant matrices with non-positive off-diagonals.  Based on the paper &quot;Approaching optimality for solving SDD systems&quot; by Koutis, Miller, and Peng, &lt;i&gt;SIAM Journal on Computing&lt;/i&gt;, 2014.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/KMPSolver.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.harmonic_interp-Tuple{Any, Vector, Vector}" href="#Laplacians.harmonic_interp-Tuple{Any, Vector, Vector}"><code>Laplacians.harmonic_interp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x = harmonic_interp(adj_mat, S, vals; tol=1e-6)</code></pre><p>Interpolates a function on a graph, given by its adjacency matrix, by minizing the Laplacian quadratic form subject to the boundary conditions that <code>x[S[i]] = vals[i]</code> for <code>i</code> in <code>S</code>.</p><p>This is the algorithm sometimes known as Label Propagation, or Semi-Supervised Learning on Graphs.  The idea comes from the paper &quot;Semi-Supervised Learning Using Gaussian Fields and Harmonic Functions&quot; by Zhu, Gharamani, and Lafferty from ICML 2003.</p><p>This version might fail for disconnected graphs. You can check if a graph is connected with <code>isConnected(adj_mat)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/9ec1c10679d3e7909087cc75116234bfa322453d/src/harmonic.jl#L1-L15">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../IO/">« IO</a><a class="docs-footer-nextpage" href="../sparsification/">sparsification »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 3 April 2024 08:29">Wednesday 3 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
