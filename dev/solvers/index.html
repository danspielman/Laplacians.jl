<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>solvers · Laplacians.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Laplacians.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">About</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../Installation/">Installation</a></li><li><a class="toctext" href="../Examples/">Examples</a></li><li><a class="toctext" href="../CSCgraph/">Sparse matrices as graphs</a></li><li><a class="toctext" href="../usingSolvers/">Solving Linear Equations</a></li><li><a class="toctext" href="../LSST/">Low Stretch Spanning Trees</a></li></ul></li><li><a class="toctext" href="../Developing/">Developing</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../graphGenerators/">generators</a></li><li><a class="toctext" href="../operators/">operators</a></li><li><a class="toctext" href="../graphUtils/">graphUtils</a></li><li><a class="toctext" href="../graphAlgs/">graphAlgs</a></li><li><a class="toctext" href="../IO/">IO</a></li><li class="current"><a class="toctext" href>solvers</a><ul class="internal"></ul></li><li><a class="toctext" href="../sparsification/">sparsification</a></li><li><a class="toctext" href="../akpw/">akpw</a></li><li><a class="toctext" href="../treeAlgs/">treeAlgs</a></li><li><a class="toctext" href="../randTrees/">randTrees</a></li><li><a class="toctext" href="../localClustering/">localClustering</a></li><li><a class="toctext" href="../privateFuncs/">Private Functions</a></li><li><a class="toctext" href="../indexOfAll/">All of the above</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>solvers</a></li></ul><a class="edit-page" href="https://github.com/danspielman/Laplacians.jl/blob/master/docs/src/solvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Linear-Equation-Solvers-1" href="#Linear-Equation-Solvers-1">Linear Equation Solvers</a></h1><p>For more, see the page <a href="../usingSolvers/">on using solvers</a>.</p><ul><li><a href="#Laplacians.ApproxCholParams"><code>Laplacians.ApproxCholParams</code></a></li><li><a href="#Laplacians.KMPParams"><code>Laplacians.KMPParams</code></a></li><li><a href="#Laplacians.KMPLapSolver-Tuple{Any}"><code>Laplacians.KMPLapSolver</code></a></li><li><a href="#Laplacians.KMPSDDMSolver-Tuple{Any}"><code>Laplacians.KMPSDDMSolver</code></a></li><li><a href="#Laplacians.approxchol_lap-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.approxchol_lap</code></a></li><li><a href="#Laplacians.approxchol_sddm"><code>Laplacians.approxchol_sddm</code></a></li><li><a href="#Laplacians.augTreeLap-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.augTreeLap</code></a></li><li><a href="#Laplacians.augTreeLapPrecon-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.augTreeLapPrecon</code></a></li><li><a href="#Laplacians.augTreePrecon-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.augTreePrecon</code></a></li><li><a href="#Laplacians.augTreeSddm-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.augTreeSddm</code></a></li><li><a href="#Laplacians.augmentTree-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv,Ti},SparseMatrixCSC{Tv,Ti},Ti}} where Ti where Tv"><code>Laplacians.augmentTree</code></a></li><li><a href="#Laplacians.cg"><code>Laplacians.cg</code></a></li><li><a href="#Laplacians.cgLapSolver-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.cgLapSolver</code></a></li><li><a href="#Laplacians.cgSolver"><code>Laplacians.cgSolver</code></a></li><li><a href="#Laplacians.chol_lap"><code>Laplacians.chol_lap</code></a></li><li><a href="#Laplacians.chol_sddm"><code>Laplacians.chol_sddm</code></a></li><li><a href="#Laplacians.condNumber-Tuple{Any,Any}"><code>Laplacians.condNumber</code></a></li><li><a href="#Laplacians.harmonic_interp-Tuple{Any,Array{T,1} where T,Array{T,1} where T}"><code>Laplacians.harmonic_interp</code></a></li><li><a href="#Laplacians.lapWrapSDDM-Tuple{Any,AbstractArray}"><code>Laplacians.lapWrapSDDM</code></a></li><li><a href="#Laplacians.pcg"><code>Laplacians.pcg</code></a></li><li><a href="#Laplacians.pcgLapSolver-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>Laplacians.pcgLapSolver</code></a></li><li><a href="#Laplacians.pcgSolver"><code>Laplacians.pcgSolver</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.chol_lap" href="#Laplacians.chol_lap"><code>Laplacians.chol_lap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solver = chol_lap(A::AbstractArray)</code></pre><p>Uses Cholesky Factorization to solve systems in Laplacians.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/solverInterface.jl#L295-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.chol_sddm" href="#Laplacians.chol_sddm"><code>Laplacians.chol_sddm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solveSDDM = chol_sddm(sddm::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[])</code></pre><p>This functions wraps cholfact so that it satsfies our interface. It ignores all the keyword arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/solverInterface.jl#L73-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.lapWrapSDDM-Tuple{Any,AbstractArray}" href="#Laplacians.lapWrapSDDM-Tuple{Any,AbstractArray}"><code>Laplacians.lapWrapSDDM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">f = lapWrapSDDM(sddmSolver, A::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)
f = lapWrapSDDM(sddmSolver)</code></pre><p>Uses a <code>sddmSolver</code> to solve systems of linear equations in Laplacian matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/solverInterface.jl#L270-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.cg" href="#Laplacians.cg"><code>Laplacians.cg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = cg(mat, b; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>solves a symmetric linear system <code>mat x = b</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tol</code> is set to 1e-6 by default,</li><li><code>maxits</code> defaults to Inf</li><li><code>maxtime</code> defaults to Inf.  It measures seconds.</li><li><code>verbose</code> defaults to false</li><li><code>pcgIts</code> is an array for returning the number of pcgIterations.  Default is length 0, in which case nothing is returned.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/pcg.jl#L13-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.cgLapSolver-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.cgLapSolver-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.cgLapSolver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">x = cgLapSolver(A::AbstractMatrix; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[])</code></pre><p>Create a solver that uses cg to solve Laplacian systems in the laplacian of A. This just exists to satisfy our interface. It does nothing more than create the Laplacian and call cg on each connected component.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/pcg.jl#L73-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.cgSolver" href="#Laplacians.cgSolver"><code>Laplacians.cgSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = cgSolver(mat; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>creates a solver for a PSD system <code>mat</code>. The parameters are as described in cg.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/pcg.jl#L42-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pcg" href="#Laplacians.pcg"><code>Laplacians.pcg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = pcg(mat, b, pre; tol, maxits, maxtime, verbose, pcgIts, stag_test)`</code></pre><p>solves a symmetric linear system using preconditioner <code>pre</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pre</code> can be a function or a matrix.  If a matrix, a function to solve it is created with cholFact.</li><li><code>tol</code> is set to 1e-6 by default,</li><li><code>maxits</code> defaults to Inf</li><li><code>maxtime</code> defaults to Inf.  It measures seconds.</li><li><code>verbose</code> defaults to false</li><li><code>pcgIts</code> is an array for returning the number of pcgIterations.  Default is length 0, in which case nothing is returned.</li><li><code>stag_test=k</code> stops the code if rho[it] &gt; (1-1/k) rho[it-k].  Set to 0 to deactivate.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/pcg.jl#L26-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pcgLapSolver-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}" href="#Laplacians.pcgLapSolver-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>Laplacians.pcgLapSolver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">x = pcgLapSolver(A, B; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[])</code></pre><p>Create a solver that uses pcg to solve Laplacian systems in <code>A</code> Specialized for the case when the preconditioner the Laplacian matrix of <code>B</code>. It solves the preconditioner by Cholesky Factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/pcg.jl#L124-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pcgSolver" href="#Laplacians.pcgSolver"><code>Laplacians.pcgSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">x = pcgSolver(mat, pre; tol, maxits, maxtime, verbose, pcgIts)</code></pre><p>creates a solver for a PSD system using preconditioner <code>pre</code>. The parameters are as described in pcg.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/pcg.jl#L51-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ApproxCholParams" href="#Laplacians.ApproxCholParams"><code>Laplacians.ApproxCholParams</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">params = ApproxCholParams(order, output)</code></pre><p>order can be one of</p><ul><li>:deg (by degree, adaptive),</li><li>:wdeg (by original wted degree, nonadaptive),</li><li>:given</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/approxChol.jl#L38-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxchol_lap-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.approxchol_lap-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.approxchol_lap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">solver = approxchol_lap(a); x = solver(b);
solver = approxchol_lap(a; tol::Real=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())</code></pre><p>A heuristic by Daniel Spielman inspired by the linear system solver in https://arxiv.org/abs/1605.02353 by Rasmus Kyng and Sushant Sachdeva.  Whereas that paper eliminates vertices one at a time, this eliminates edges one at a time.  It is probably possible to analyze it. The <code>ApproxCholParams</code> let you choose one of three orderings to perform the elimination.</p><ul><li>ApproxCholParams(:given) - in the order given.   This is the fastest for construction the preconditioner, but the slowest solve.</li><li>ApproxCholParams(:deg) - always eliminate the node of lowest degree.   This is the slowest build, but the fastest solve.</li><li>ApproxCholParams(:wdeg) - go by a perturbed order of wted degree.</li></ul><p>For more info, see http://danspielman.github.io/Laplacians.jl/latest/usingSolvers/index.html</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/approxChol.jl#L729-L743">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxchol_sddm" href="#Laplacians.approxchol_sddm"><code>Laplacians.approxchol_sddm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solver = approxchol_sddm(sddm); x = solver(b);
solver = approxchol_sddm(sddm; tol=1e-6, maxits=1000, maxtime=Inf, verbose=false, pcgIts=Int[], params=ApproxCholParams())</code></pre><p>Solves sddm systems by wrapping approxchol_lap. Not yet optimized directly for sddm.</p><p>For more info, see http://danspielman.github.io/Laplacians.jl/latest/usingSolvers/index.html</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/approxChol.jl#L941-L949">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.condNumber-Tuple{Any,Any}" href="#Laplacians.condNumber-Tuple{Any,Any}"><code>Laplacians.condNumber</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cn = condNumber(a, ldli; verbose=false)</code></pre><p>Given an adjacency matrix a and an ldli computed by approxChol, this computes the condition number.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/approxChol.jl#L961-L966">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augTreeLap-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.augTreeLap-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.augTreeLap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">solver = augTreeLap(A; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params=AugTreeParams())</code></pre><p>An &quot;augmented spanning tree&quot; solver for Laplacians.  It works by adding edges to a low stretch spanning tree.  It calls <code>augTreePrecon</code> to form the preconditioner.  <code>params</code> has entries</p><ul><li><code>params.treeAlg</code> default to <code>akpw</code></li><li><code>params.opt</code> if true, it interacts with cholmod to choose a good number of edges to add back.  If false, it adds back 2*sqrt(n).</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/augTreeSolver.jl#L283-L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augTreeLapPrecon-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.augTreeLapPrecon-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.augTreeLapPrecon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pre = augTreeLapPrecon{Tv,Ti}(A; params=AugTreeParams())</code></pre><p>This is an augmented spanning tree preconditioner for Laplacians. It takes as optional input a tree growing algorithm. It adds back 2sqrt(n) edges via <code>augmentTree</code>: the sqrt(n) of highest stretch and another sqrt(n) sampled according to stretch. For most purposes, one should directly call <code>augTreeLapSolver</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/augTreeSolver.jl#L252-L259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augTreePrecon-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.augTreePrecon-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.augTreePrecon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pre = augTreePrecon{Tv,Ti}(ddmat::SparseMatrixCSC{Tv,Ti}; params=AugTreeParams())</code></pre><p>This is an augmented spanning tree preconditioner for diagonally dominant linear systems.  It takes as optional input a tree growing algorithm. It adds back 2sqrt(n) edges via augmentTree: the sqrt(n) of highest stretch and another sqrt(n) sampled according to stretch. For most purposes, one should directly call <code>augTreeSolver</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/augTreeSolver.jl#L187-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augTreeSddm-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.augTreeSddm-Union{Tuple{SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.augTreeSddm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">solver = augTreeSddm(sddm; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[],  params=AugTreeParams())</code></pre><p>An &quot;augmented spanning tree&quot; solver for positive definite diagonally dominant matrices.  It works by adding edges to a low stretch spanning tree.  It calls <code>augTreePrecon</code> to form the preconditioner.  <code>params</code> has entries</p><ul><li><code>params.treeAlg</code> default to <code>akpw</code></li><li><code>params.opt</code> if true, it interacts with cholmod to choose a good number of edges to add back.  If false, it adds back 2*sqrt(n).</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/augTreeSolver.jl#L223-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augmentTree-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv,Ti},SparseMatrixCSC{Tv,Ti},Ti}} where Ti where Tv" href="#Laplacians.augmentTree-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv,Ti},SparseMatrixCSC{Tv,Ti},Ti}} where Ti where Tv"><code>Laplacians.augmentTree</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">B = augmentTree{Tv,Ti}(tree, A, k)</code></pre><p>Takes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It then adds back the k edges of highest stretch, and k edges sampled according to stretch.</p><p>This is the old alg.  We now recommend using augmentTreeOpt.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/augTreeSolver.jl#L30-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.KMPParams" href="#Laplacians.KMPParams"><code>Laplacians.KMPParams</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Parameters for the KMP solver</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/KMPSolver.jl#L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.KMPLapSolver-Tuple{Any}" href="#Laplacians.KMPLapSolver-Tuple{Any}"><code>Laplacians.KMPLapSolver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lapSolver = KMPLapSolver(A; verbose, tol, maxits, maxtime, pcgIts, params::KMPParams)</code></pre><p>Solves linear equations in the Laplacian of graph with adjacency matrix <code>A</code>.</p><p>Based on the paper &quot;Approaching optimality for solving SDD systems&quot; by Koutis, Miller, and Peng, &lt;i&gt;SIAM Journal on Computing&lt;/i&gt;, 2014.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/KMPSolver.jl#L235-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.KMPSDDMSolver-Tuple{Any}" href="#Laplacians.KMPSDDMSolver-Tuple{Any}"><code>Laplacians.KMPSDDMSolver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sddmSolver = KMPSDDMSolver(mat; verbose, tol, maxits, maxtime, pcgIts, params::KMPParams)</code></pre><p>Solves linear equations in symmetric, diagonally dominant matrices with non-positive off-diagonals.  Based on the paper &quot;Approaching optimality for solving SDD systems&quot; by Koutis, Miller, and Peng, &lt;i&gt;SIAM Journal on Computing&lt;/i&gt;, 2014.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/KMPSolver.jl#L187-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.harmonic_interp-Tuple{Any,Array{T,1} where T,Array{T,1} where T}" href="#Laplacians.harmonic_interp-Tuple{Any,Array{T,1} where T,Array{T,1} where T}"><code>Laplacians.harmonic_interp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">x = harmonic_interp(adj_mat, S, vals; tol=1e-6)</code></pre><p>Interpolates a function on a graph, given by its adjacency matrix, by minizing the Laplacian quadratic form subject to the boundary conditions that <code>x[S[i]] = vals[i]</code> for <code>i</code> in <code>S</code>.</p><p>This is the algorithm sometimes known as Label Propagation, or Semi-Supervised Learning on Graphs.  The idea comes from the paper &quot;Semi-Supervised Learning Using Gaussian Fields and Harmonic Functions&quot; by Zhu, Gharamani, and Lafferty from ICML 2003.</p><p>This version might fail for disconnected graphs. You can check if a graph is connected with <code>isConnected(adj_mat)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/af8eae4a75481f504e4734404aedfb095586fe62/src/harmonic.jl#L1-L15">source</a></section><footer><hr/><a class="previous" href="../IO/"><span class="direction">Previous</span><span class="title">IO</span></a><a class="next" href="../sparsification/"><span class="direction">Next</span><span class="title">sparsification</span></a></footer></article></body></html>
