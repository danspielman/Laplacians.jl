<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>operators · Laplacians.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Laplacians.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">About</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../Installation/">Installation</a></li><li><a class="toctext" href="../Examples/">Examples</a></li><li><a class="toctext" href="../CSCgraph/">Sparse matrices as graphs</a></li><li><a class="toctext" href="../usingSolvers/">Solving Linear Equations</a></li><li><a class="toctext" href="../LSST/">Low Stretch Spanning Trees</a></li></ul></li><li><a class="toctext" href="../Developing/">Developing</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../graphGenerators/">generators</a></li><li class="current"><a class="toctext" href>operators</a><ul class="internal"><li><a class="toctext" href="#Function-list-1">Function list</a></li></ul></li><li><a class="toctext" href="../graphUtils/">graphUtils</a></li><li><a class="toctext" href="../graphAlgs/">graphAlgs</a></li><li><a class="toctext" href="../IO/">IO</a></li><li><a class="toctext" href="../solvers/">solvers</a></li><li><a class="toctext" href="../sparsification/">sparsification</a></li><li><a class="toctext" href="../akpw/">akpw</a></li><li><a class="toctext" href="../treeAlgs/">treeAlgs</a></li><li><a class="toctext" href="../randTrees/">randTrees</a></li><li><a class="toctext" href="../localClustering/">localClustering</a></li><li><a class="toctext" href="../privateFuncs/">Private Functions</a></li><li><a class="toctext" href="../indexOfAll/">All of the above</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>operators</a></li></ul><a class="edit-page" href="https://github.com/danspielman/Laplacians.jl/blob/master/docs/src/operators.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>operators</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Operators-1" href="#Operators-1">Operators</a></h1><p>Operators transform graphs to produce new graphs.</p><h2><a class="nav-anchor" id="Function-list-1" href="#Function-list-1">Function list</a></h2><ul></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.adj-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.adj-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.adj</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">a,d = adj(sddm)</code></pre><p>Create an adjacency matrix and a diagonal vector from an SDD M-matrix. That is, from a Laplacian with added diagonal weights</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L27-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.diagmat-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.diagmat-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.diagmat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">d = diagmat(a)</code></pre><p>Returns the diagonal weighted degree matrix(as a sparse matrix) of a graph</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L703-L707">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.disjoin-Tuple{SparseArrays.SparseMatrixCSC,SparseArrays.SparseMatrixCSC}" href="#Laplacians.disjoin-Tuple{SparseArrays.SparseMatrixCSC,SparseArrays.SparseMatrixCSC}"><code>Laplacians.disjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">graph = disjoin(a,b)</code></pre><p>Create a disjoint union of graphs a and b,   with no edges between them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L545-L550">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.edgeVertexMat-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.edgeVertexMat-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.edgeVertexMat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">U = edgeVertexMat(a)</code></pre><p>The signed edge-vertex adjacency matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L373-L377">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.floatGraph-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.floatGraph-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.floatGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>graph = floatGraph(a::SparseMatrixCSC)</p><p>Convert the nonzero entries in a graph to Float64.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L11-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.join_graphs!-Tuple{Laplacians.IJV,Laplacians.IJV,Integer}" href="#Laplacians.join_graphs!-Tuple{Laplacians.IJV,Laplacians.IJV,Integer}"><code>Laplacians.join_graphs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">graph = join_graphs!(a::IJV, b::IJV, k::Integer)</code></pre><p>Create a disjoint union of graphs a and b,  and then put k random edges between them, merging b into a.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L526-L531">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.join_graphs-Union{Tuple{Tind}, Tuple{Tval}, Tuple{SparseArrays.SparseMatrixCSC{Tval,Tind},SparseArrays.SparseMatrixCSC{Tval,Tind},Integer}} where Tind where Tval" href="#Laplacians.join_graphs-Union{Tuple{Tind}, Tuple{Tval}, Tuple{SparseArrays.SparseMatrixCSC{Tval,Tind},SparseArrays.SparseMatrixCSC{Tval,Tind},Integer}} where Tind where Tval"><code>Laplacians.join_graphs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">graph = joinGraphs(a, b, k::Integer)</code></pre><p>Create a disjoint union of graphs a and b,  and then put k random edges between them</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L492-L497">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.lap-Tuple{Any}" href="#Laplacians.lap-Tuple{Any}"><code>Laplacians.lap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">l = lap(a)</code></pre><p>Create a Laplacian matrix from an adjacency matrix. We might want to do this differently, say by enforcing symmetry</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L20-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.line_graph-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.line_graph-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.line_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">H = line_graph(G::SparseMatrixCSC)</code></pre><p>Let G = (V, E) be a graph. The line graph of G is the graph whose vertices are the edges of G in which two are connected if they share an endpoint in G. That is, (u, v),(w, z) is an edge of the line graph if one of {u, v} is the same as one of {w, z}</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L385-L390">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.mapweight-Union{Tuple{Tind}, Tuple{Tval}, Tuple{SparseArrays.SparseMatrixCSC{Tval,Tind},Any}} where Tind where Tval" href="#Laplacians.mapweight-Union{Tuple{Tind}, Tuple{Tval}, Tuple{SparseArrays.SparseMatrixCSC{Tval,Tind},Any}} where Tind where Tval"><code>Laplacians.mapweight</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">b = mapweight(a, x-&gt;rand())</code></pre><p>Create a new graph that is the same as the original, but with f applied to each nonzero entry of a. For example, to make the weight of every edge uniform in [0,1], we could write.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L105-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.plot_graph-NTuple{4,Any}" href="#Laplacians.plot_graph-NTuple{4,Any}"><code>Laplacians.plot_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_graph(gr,x,y,z;color=[0,0,1],dots=true,setaxis=true,number=false)</code></pre><p>Plots graph gr with coordinates (x,y,z)</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L625-L629">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.plot_graph-Tuple{Any,Any,Any}" href="#Laplacians.plot_graph-Tuple{Any,Any,Any}"><code>Laplacians.plot_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">plot_graph(gr,x,y;color=[0,0,1],dots=true,setaxis=true,number=false)</code></pre><p>Plots graph gr with coordinates (x,y)</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L580-L584">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.power-Tuple{SparseArrays.SparseMatrixCSC,Int64}" href="#Laplacians.power-Tuple{SparseArrays.SparseMatrixCSC,Int64}"><code>Laplacians.power</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ap = power(a::SparseMatrixCSC, k::Int)</code></pre><p>Returns the kth power of a.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L179-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.product_graph-Tuple{SparseArrays.SparseMatrixCSC,SparseArrays.SparseMatrixCSC}" href="#Laplacians.product_graph-Tuple{SparseArrays.SparseMatrixCSC,SparseArrays.SparseMatrixCSC}"><code>Laplacians.product_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">aprod = productGraph(a0, a1)</code></pre><p>The Cartesian product of two graphs.  When applied to two paths, it gives a grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L144-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.shortIntGraph-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.shortIntGraph-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.shortIntGraph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">graph = shortIntGraph(a::SparseMatrixCSC)</code></pre><p>Convert the indices in a graph to 32-bit ints. This takes less storage, but does not speed up much.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L2-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.spectral_coords-Tuple{Any}" href="#Laplacians.spectral_coords-Tuple{Any}"><code>Laplacians.spectral_coords</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">x, y = spectral_coords(a)</code></pre><p>Computes the spectral coordinates of a graph. If more than 2 coords are desired, you can use</p><pre><code class="language-none">    x, y, z = spectral_coords(a; k = 3)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L685-L693">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.spectral_drawing-Tuple{Any}" href="#Laplacians.spectral_drawing-Tuple{Any}"><code>Laplacians.spectral_drawing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">spectral_drawing(a)</code></pre><p>Computes spectral coordinates, and then uses plot_graph to draw</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L673-L677">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.subsampleEdges-Tuple{SparseArrays.SparseMatrixCSC,Float64}" href="#Laplacians.subsampleEdges-Tuple{SparseArrays.SparseMatrixCSC,Float64}"><code>Laplacians.subsampleEdges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">graph = subsampleEdges(a::SparseMatrixCSC, p::Float64)</code></pre><p>Create a new graph from the old, but keeping edge edge with probability <code>p</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L410-L414">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.thicken-Tuple{SparseArrays.SparseMatrixCSC,Any}" href="#Laplacians.thicken-Tuple{SparseArrays.SparseMatrixCSC,Any}"><code>Laplacians.thicken</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">a_new = thicken(A,k)</code></pre><p>Create a new graph with at least k times as many edges as A By connecting nodes with common neighbors at random. When this stops working (not enough new edges), repeat on the most recently produced graph. If k is too big, it is decreased so the average degree will not be pushed much above n/2.</p><p>When called without k, it just runs thicken_once.</p><p>For example:</p><pre><code class="language-none">a = grid2(5)
a2 = thicken(a,3)
(x,y) = grid2coords(5,5);
plotGraph(a2,x,y)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L227-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.thicken_once-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.thicken_once-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.thicken_once</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">a_new = thicken_once(a)</code></pre><p>Creates one edge for every vertex in a of degree &gt; 1 by connecting two of its random neighbors. To use this to thicken a, return unweight(a + a_new).</p><pre><code class="language-none">a = grid2(5)
a2 = unweight(a + thicken_once(a))
(x,y) = grid2coords(5,5);
plotGraph(a2,x,y)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L190-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.two_lift-Tuple{SparseArrays.SparseMatrixCSC,AbstractArray{Bool,1}}" href="#Laplacians.two_lift-Tuple{SparseArrays.SparseMatrixCSC,AbstractArray{Bool,1}}"><code>Laplacians.two_lift</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">graph = two_lift(a, flip::AbstractArray{Bool,1})
graph = two_lift(a)
graph = two_lift(a, k::Integer)</code></pre><p>Creats a 2-lift of a.  <code>flip</code> is a boolean indicating which edges cross. In the third version, k is the number of edges that cross.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L426-L433">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.uniformWeight!-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.uniformWeight!-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.uniformWeight!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">uniformWeight!(a)</code></pre><p>Set the weight of every edge to random uniform [0,1]</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L130-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.unweight!-Union{Tuple{SparseArrays.SparseMatrixCSC{Tval,Tind}}, Tuple{Tind}, Tuple{Tval}} where Tind where Tval" href="#Laplacians.unweight!-Union{Tuple{SparseArrays.SparseMatrixCSC{Tval,Tind}}, Tuple{Tind}, Tuple{Tval}} where Tind where Tval"><code>Laplacians.unweight!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">unweight!(a)</code></pre><p>Change the weight of every edge in a to 1</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L87-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.unweight-Union{Tuple{SparseArrays.SparseMatrixCSC{Tval,Tind}}, Tuple{Tind}, Tuple{Tval}} where Tind where Tval" href="#Laplacians.unweight-Union{Tuple{SparseArrays.SparseMatrixCSC{Tval,Tind}}, Tuple{Tind}, Tuple{Tval}} where Tind where Tval"><code>Laplacians.unweight</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wt1 = unweight(a)</code></pre><p>Create a new graph in that is the same as the original, but with all edge weights 1</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L73-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wtedEdgeVertexMat-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.wtedEdgeVertexMat-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.wtedEdgeVertexMat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">U = wtedEdgeVertexMat(a)</code></pre><p>The signed and weighted edge-vertex adjacency matrix, so U&#39;*U = L</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/d28eb6c37ce6371f1d4170a5bb7a896d3870ad19/src/graphOps.jl#L397-L401">source</a></section><footer><hr/><a class="previous" href="../graphGenerators/"><span class="direction">Previous</span><span class="title">generators</span></a><a class="next" href="../graphUtils/"><span class="direction">Next</span><span class="title">graphUtils</span></a></footer></article></body></html>
