<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>operators · Laplacians.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Laplacians.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">About</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../Installation/">Installation</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../CSCgraph/">Sparse matrices as graphs</a></li><li><a class="tocitem" href="../usingSolvers/">Solving Linear Equations</a></li><li><a class="tocitem" href="../LSST/">Low Stretch Spanning Trees</a></li></ul></li><li><a class="tocitem" href="../Developing/">Developing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../graphGenerators/">generators</a></li><li class="is-active"><a class="tocitem" href>operators</a><ul class="internal"><li><a class="tocitem" href="#Function-list-1"><span>Function list</span></a></li></ul></li><li><a class="tocitem" href="../graphUtils/">graphUtils</a></li><li><a class="tocitem" href="../graphAlgs/">graphAlgs</a></li><li><a class="tocitem" href="../IO/">IO</a></li><li><a class="tocitem" href="../solvers/">solvers</a></li><li><a class="tocitem" href="../sparsification/">sparsification</a></li><li><a class="tocitem" href="../akpw/">akpw</a></li><li><a class="tocitem" href="../treeAlgs/">treeAlgs</a></li><li><a class="tocitem" href="../randTrees/">randTrees</a></li><li><a class="tocitem" href="../localClustering/">localClustering</a></li><li><a class="tocitem" href="../privateFuncs/">Private Functions</a></li><li><a class="tocitem" href="../indexOfAll/">All of the above</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>operators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/danspielman/Laplacians.jl/blob/master/docs/src/operators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Operators-1"><a class="docs-heading-anchor" href="#Operators-1">Operators</a><a class="docs-heading-anchor-permalink" href="#Operators-1" title="Permalink"></a></h1><p>Operators transform graphs to produce new graphs.</p><h2 id="Function-list-1"><a class="docs-heading-anchor" href="#Function-list-1">Function list</a><a class="docs-heading-anchor-permalink" href="#Function-list-1" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-binding" id="Laplacians.adj-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.adj-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.adj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a,d = adj(sddm)</code></pre><p>Create an adjacency matrix and a diagonal vector from an SDD M-matrix. That is, from a Laplacian with added diagonal weights</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.diagmat-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.diagmat-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.diagmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">d = diagmat(a)</code></pre><p>Returns the diagonal weighted degree matrix(as a sparse matrix) of a graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L711-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.disjoin-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}" href="#Laplacians.disjoin-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>Laplacians.disjoin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph = disjoin(a,b)</code></pre><p>Create a disjoint union of graphs a and b,   with no edges between them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L553-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.edgeVertexMat-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.edgeVertexMat-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.edgeVertexMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">U = edgeVertexMat(a)</code></pre><p>The signed edge-vertex adjacency matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L381-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.floatGraph-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.floatGraph-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.floatGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>graph = floatGraph(a::SparseMatrixCSC)</p><p>Convert the nonzero entries in a graph to Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.join_graphs!-Tuple{Laplacians.IJV, Laplacians.IJV, Integer}" href="#Laplacians.join_graphs!-Tuple{Laplacians.IJV, Laplacians.IJV, Integer}"><code>Laplacians.join_graphs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph = join_graphs!(a::IJV, b::IJV, k::Integer)</code></pre><p>Create a disjoint union of graphs a and b,  and then put k random edges between them, merging b into a.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L534-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.join_graphs-Union{Tuple{Tind}, Tuple{Tval}, Tuple{SparseArrays.SparseMatrixCSC{Tval, Tind}, SparseArrays.SparseMatrixCSC{Tval, Tind}, Integer}} where {Tval, Tind}" href="#Laplacians.join_graphs-Union{Tuple{Tind}, Tuple{Tval}, Tuple{SparseArrays.SparseMatrixCSC{Tval, Tind}, SparseArrays.SparseMatrixCSC{Tval, Tind}, Integer}} where {Tval, Tind}"><code>Laplacians.join_graphs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph = joinGraphs(a, b, k::Integer)</code></pre><p>Create a disjoint union of graphs a and b,  and then put k random edges between them</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L500-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.lap-Tuple{Any}" href="#Laplacians.lap-Tuple{Any}"><code>Laplacians.lap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">l = lap(a)</code></pre><p>Create a Laplacian matrix from an adjacency matrix. We might want to do this differently, say by enforcing symmetry</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.line_graph-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.line_graph-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.line_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H = line_graph(G::SparseMatrixCSC)</code></pre><p>Let G = (V, E) be a graph. The line graph of G is the graph whose vertices are the edges of G in which two are connected if they share an endpoint in G. That is, (u, v),(w, z) is an edge of the line graph if one of {u, v} is the same as one of {w, z}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L393-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.mapweight-Union{Tuple{Tind}, Tuple{Tval}, Tuple{SparseArrays.SparseMatrixCSC{Tval, Tind}, Any}} where {Tval, Tind}" href="#Laplacians.mapweight-Union{Tuple{Tind}, Tuple{Tval}, Tuple{SparseArrays.SparseMatrixCSC{Tval, Tind}, Any}} where {Tval, Tind}"><code>Laplacians.mapweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">b = mapweight(a, x-&gt;rand())</code></pre><p>Create a new graph that is the same as the original, but with f applied to each nonzero entry of a. For example, to make the weight of every edge uniform in [0,1], we could write.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.plot_graph-NTuple{4, Any}" href="#Laplacians.plot_graph-NTuple{4, Any}"><code>Laplacians.plot_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_graph(gr,x,y,z;color=[0,0,1],dots=true,setaxis=true,number=false)</code></pre><p>Plots graph gr with coordinates (x,y,z)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L633-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.plot_graph-Tuple{Any, Any, Any}" href="#Laplacians.plot_graph-Tuple{Any, Any, Any}"><code>Laplacians.plot_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_graph(gr,x,y;color=[0,0,1],dots=true,setaxis=true,number=false)</code></pre><p>Plots graph gr with coordinates (x,y)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L588-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.power-Tuple{SparseArrays.SparseMatrixCSC, Int64}" href="#Laplacians.power-Tuple{SparseArrays.SparseMatrixCSC, Int64}"><code>Laplacians.power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ap = power(a::SparseMatrixCSC, k::Int)</code></pre><p>Returns the kth power of a.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.product_graph-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}" href="#Laplacians.product_graph-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>Laplacians.product_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aprod = productGraph(a0, a1)</code></pre><p>The Cartesian product of two graphs.  When applied to two paths, it gives a grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.shortIntGraph-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.shortIntGraph-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.shortIntGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph = shortIntGraph(a::SparseMatrixCSC)</code></pre><p>Convert the indices in a graph to 32-bit ints. This takes less storage, but does not speed up much.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.spectral_coords-Tuple{Any}" href="#Laplacians.spectral_coords-Tuple{Any}"><code>Laplacians.spectral_coords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x, y = spectral_coords(a)</code></pre><p>Computes the spectral coordinates of a graph. If more than 2 coords are desired, you can use</p><pre><code class="language-none">    x, y, z = spectral_coords(a; k = 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L693-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.spectral_drawing-Tuple{Any}" href="#Laplacians.spectral_drawing-Tuple{Any}"><code>Laplacians.spectral_drawing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spectral_drawing(a)</code></pre><p>Computes spectral coordinates, and then uses plot_graph to draw</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L681-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.subsampleEdges-Tuple{SparseArrays.SparseMatrixCSC, Float64}" href="#Laplacians.subsampleEdges-Tuple{SparseArrays.SparseMatrixCSC, Float64}"><code>Laplacians.subsampleEdges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph = subsampleEdges(a::SparseMatrixCSC, p::Float64)</code></pre><p>Create a new graph from the old, but keeping edge edge with probability <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L418-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.thicken-Tuple{SparseArrays.SparseMatrixCSC, Any}" href="#Laplacians.thicken-Tuple{SparseArrays.SparseMatrixCSC, Any}"><code>Laplacians.thicken</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a_new = thicken(A,k)</code></pre><p>Create a new graph with at least k times as many edges as A By connecting nodes with common neighbors at random. When this stops working (not enough new edges), repeat on the most recently produced graph. If k is too big, it is decreased so the average degree will not be pushed much above n/2.</p><p>When called without k, it just runs thicken_once.</p><p>For example:</p><pre><code class="language-none">a = grid2(5)
a2 = thicken(a,3)
(x,y) = grid2coords(5,5);
plotGraph(a2,x,y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L235-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.thicken_once-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.thicken_once-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.thicken_once</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a_new = thicken_once(a)</code></pre><p>Creates one edge for every vertex in a of degree &gt; 1 by connecting two of its random neighbors. To use this to thicken a, return unweight(a + a_new).</p><pre><code class="language-none">a = grid2(5)
a2 = unweight(a + thicken_once(a))
(x,y) = grid2coords(5,5);
plotGraph(a2,x,y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L198-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.two_lift-Tuple{SparseArrays.SparseMatrixCSC, AbstractVector{Bool}}" href="#Laplacians.two_lift-Tuple{SparseArrays.SparseMatrixCSC, AbstractVector{Bool}}"><code>Laplacians.two_lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph = two_lift(a, flip::AbstractArray{Bool,1})
graph = two_lift(a)
graph = two_lift(a, k::Integer)</code></pre><p>Creats a 2-lift of a.  <code>flip</code> is a boolean indicating which edges cross. In the third version, k is the number of edges that cross.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L434-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.uniformWeight!-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.uniformWeight!-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.uniformWeight!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uniformWeight!(a)</code></pre><p>Set the weight of every edge to random uniform [0,1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.unweight!-Union{Tuple{SparseArrays.SparseMatrixCSC{Tval, Tind}}, Tuple{Tind}, Tuple{Tval}} where {Tval, Tind}" href="#Laplacians.unweight!-Union{Tuple{SparseArrays.SparseMatrixCSC{Tval, Tind}}, Tuple{Tind}, Tuple{Tval}} where {Tval, Tind}"><code>Laplacians.unweight!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unweight!(a)</code></pre><p>Change the weight of every edge in a to 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.unweight-Union{Tuple{SparseArrays.SparseMatrixCSC{Tval, Tind}}, Tuple{Tind}, Tuple{Tval}} where {Tval, Tind}" href="#Laplacians.unweight-Union{Tuple{SparseArrays.SparseMatrixCSC{Tval, Tind}}, Tuple{Tind}, Tuple{Tval}} where {Tval, Tind}"><code>Laplacians.unweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wt1 = unweight(a)</code></pre><p>Create a new graph in that is the same as the original, but with all edge weights 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.wtedEdgeVertexMat-Tuple{SparseArrays.SparseMatrixCSC}" href="#Laplacians.wtedEdgeVertexMat-Tuple{SparseArrays.SparseMatrixCSC}"><code>Laplacians.wtedEdgeVertexMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">U = wtedEdgeVertexMat(a)</code></pre><p>The signed and weighted edge-vertex adjacency matrix, so U&#39;*U = L</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/bdd13a8ca0684c44006a279fd36b84dc0c00b8e1/src/graphOps.jl#L405-L409">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphGenerators/">« generators</a><a class="docs-footer-nextpage" href="../graphUtils/">graphUtils »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 28 February 2023 14:52">Tuesday 28 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
