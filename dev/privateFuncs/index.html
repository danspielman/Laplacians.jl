<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Private Functions · Laplacians.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Laplacians.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">About</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../Installation/">Installation</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../CSCgraph/">Sparse matrices as graphs</a></li><li><a class="tocitem" href="../usingSolvers/">Solving Linear Equations</a></li><li><a class="tocitem" href="../LSST/">Low Stretch Spanning Trees</a></li></ul></li><li><a class="tocitem" href="../Developing/">Developing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../graphGenerators/">generators</a></li><li><a class="tocitem" href="../operators/">operators</a></li><li><a class="tocitem" href="../graphUtils/">graphUtils</a></li><li><a class="tocitem" href="../graphAlgs/">graphAlgs</a></li><li><a class="tocitem" href="../IO/">IO</a></li><li><a class="tocitem" href="../solvers/">solvers</a></li><li><a class="tocitem" href="../sparsification/">sparsification</a></li><li><a class="tocitem" href="../akpw/">akpw</a></li><li><a class="tocitem" href="../treeAlgs/">treeAlgs</a></li><li><a class="tocitem" href="../randTrees/">randTrees</a></li><li><a class="tocitem" href="../localClustering/">localClustering</a></li><li class="is-active"><a class="tocitem" href>Private Functions</a></li><li><a class="tocitem" href="../indexOfAll/">All of the above</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Private Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Private Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/danspielman/Laplacians.jl/blob/master/docs/src/privateFuncs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Unexported-(Private)-functions.-1"><a class="docs-heading-anchor" href="#Unexported-(Private)-functions.-1">Unexported (Private) functions.</a><a class="docs-heading-anchor-permalink" href="#Unexported-(Private)-functions.-1" title="Permalink"></a></h1><p>This is a list of all unexported functions and types from Laplacians.</p><ul><li><a href="#Laplacians.ApproxCholPQ"><code>Laplacians.ApproxCholPQ</code></a></li><li><a href="#Laplacians.IJV-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.IJV</code></a></li><li><a href="#Laplacians.LDLinv"><code>Laplacians.LDLinv</code></a></li><li><a href="#Laplacians.LLmatp"><code>Laplacians.LLmatp</code></a></li><li><a href="#Laplacians.LLp"><code>Laplacians.LLp</code></a></li><li><a href="#Laplacians.approxCholPQDec!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind}, Any}} where Tind"><code>Laplacians.approxCholPQDec!</code></a></li><li><a href="#Laplacians.approxCholPQInc!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind}, Any}} where Tind"><code>Laplacians.approxCholPQInc!</code></a></li><li><a href="#Laplacians.approxchol_lapChol-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.approxchol_lapChol</code></a></li><li><a href="#Laplacians.augmentTreeOpt-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti}"><code>Laplacians.augmentTreeOpt</code></a></li><li><a href="#Laplacians.blockSolver-Tuple{Any, Any}"><code>Laplacians.blockSolver</code></a></li><li><a href="#Laplacians.complete_bipartite_graph_ijv-Tuple{Integer}"><code>Laplacians.complete_bipartite_graph_ijv</code></a></li><li><a href="#Laplacians.complete_graph_ijv-Tuple{Integer}"><code>Laplacians.complete_graph_ijv</code></a></li><li><a href="#Laplacians.empty_graph_ijv-Tuple{Integer}"><code>Laplacians.empty_graph_ijv</code></a></li><li><a href="#Laplacians.extendMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, Vector{Tv}}} where {Tv, Ti}"><code>Laplacians.extendMatrix</code></a></li><li><a href="#Laplacians.firstn-Tuple{Laplacians.IJV, Integer}"><code>Laplacians.firstn</code></a></li><li><a href="#Laplacians.forceLap-Tuple{AbstractArray}"><code>Laplacians.forceLap</code></a></li><li><a href="#Laplacians.generalizedNecklace-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC, Int64}} where {Tv, Ti}"><code>Laplacians.generalizedNecklace</code></a></li><li><a href="#Laplacians.initDictCol!-Tuple{Any, Any, Any}"><code>Laplacians.initDictCol!</code></a></li><li><a href="#Laplacians.lapWrapComponents-Tuple{Any, AbstractArray}"><code>Laplacians.lapWrapComponents</code></a></li><li><a href="#Laplacians.lapWrapConnected-Tuple{Any, AbstractMatrix}"><code>Laplacians.lapWrapConnected</code></a></li><li><a href="#Laplacians.ldli2Chol-Tuple{Any}"><code>Laplacians.ldli2Chol</code></a></li><li><a href="#Laplacians.path_graph_ijv-Tuple{Integer}"><code>Laplacians.path_graph_ijv</code></a></li><li><a href="#Laplacians.print_ll_col-Tuple{Laplacians.LLMatOrd, Int64}"><code>Laplacians.print_ll_col</code></a></li><li><a href="#Laplacians.print_ll_col-Tuple{Laplacians.LLmatp, Int64}"><code>Laplacians.print_ll_col</code></a></li><li><a href="#Laplacians.pure_random_ijv-Tuple{Integer}"><code>Laplacians.pure_random_ijv</code></a></li><li><a href="#Laplacians.pushSpeedResult!-Tuple{Any, Any, Any}"><code>Laplacians.pushSpeedResult!</code></a></li><li><a href="#Laplacians.rand_regular_bipartite-Tuple{Any, Any}"><code>Laplacians.rand_regular_bipartite</code></a></li><li><a href="#Laplacians.ring_graph_ijv-Tuple{Integer}"><code>Laplacians.ring_graph_ijv</code></a></li><li><a href="#Laplacians.sampleByWeight-Tuple{Any}"><code>Laplacians.sampleByWeight</code></a></li><li><a href="#Laplacians.sddmWrapLap-Tuple{Any, AbstractArray}"><code>Laplacians.sddmWrapLap</code></a></li><li><a href="#Laplacians.sortSet-Union{Tuple{Ti}, Tuple{Vector{Ti}, Ti}} where Ti"><code>Laplacians.sortSet</code></a></li><li><a href="#Laplacians.star_graph_ijv-Tuple{Integer}"><code>Laplacians.star_graph_ijv</code></a></li><li><a href="#Laplacians.testZeroDiag-Tuple{Any}"><code>Laplacians.testZeroDiag</code></a></li><li><a href="#Laplacians.treeDepthDFS-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.treeDepthDFS</code></a></li><li><a href="#Laplacians.uniformWeight_ver-Tuple{Type{Val{6}}, SparseArrays.SparseMatrixCSC}"><code>Laplacians.uniformWeight_ver</code></a></li><li><a href="#Laplacians.wrapCapture-Tuple{Function, Any, Any}"><code>Laplacians.wrapCapture</code></a></li><li><a href="#Laplacians.wrapCaptureRhs-Tuple{Function, Any}"><code>Laplacians.wrapCaptureRhs</code></a></li><li><a href="#Laplacians.wrapInterface-Tuple{Function, AbstractMatrix}"><code>Laplacians.wrapInterface</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Laplacians.ApproxCholPQ" href="#Laplacians.ApproxCholPQ"><code>Laplacians.ApproxCholPQ</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An approximate priority queue.   Items are bundled together into doubly-linked lists with all approximately the same key.   minlist is the min list we know to be non-empty.   It should always be a lower bound.   keyMap maps keys to lists</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxCholTypes.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.IJV-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.IJV-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.IJV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ijv = IJV(A::SparseMatrixCSC)</code></pre><p>Convert a sparse matrix to an IJV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/IJV.jl#L55-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.LDLinv" href="#Laplacians.LDLinv"><code>Laplacians.LDLinv</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LDLinv contains the information needed to solve the Laplacian systems.   It does it by applying Linv, then Dinv, then Linv (transpose).   But, it is specially constructed for this particular solver.   It does not explicitly make the matrix triangular.   Rather, col[i] is the name of the ith col to be eliminated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxCholTypes.jl#L66-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.LLmatp" href="#Laplacians.LLmatp"><code>Laplacians.LLmatp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LLmatp is the data structure used to maintain the matrix during elimination.   It stores the elements in each column in a singly linked list (only next ptrs)   Each element is an LLp (linked list pointer).   The head of each column is pointed to by cols.</p><p>We probably can get rid of degs - as it is only used to store initial degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxCholTypes.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.LLp" href="#Laplacians.LLp"><code>Laplacians.LLp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LLp elements are all in the same column.   row tells us the row, and val is the entry.   val is set to zero for some edges that we should remove.   next gives the next in the column.  It points to itself to terminate.   reverse is the index into lles of the other copy of this edge,   since every edge is stored twice as we do not know the order of elimination in advance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxCholTypes.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.approxCholPQDec!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind}, Any}} where Tind" href="#Laplacians.approxCholPQDec!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind}, Any}} where Tind"><code>Laplacians.approxCholPQDec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Decrement the key of element i
This could crash if i exceeds the maxkey</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxChol.jl#L1251-L1254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.approxCholPQInc!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind}, Any}} where Tind" href="#Laplacians.approxCholPQInc!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind}, Any}} where Tind"><code>Laplacians.approxCholPQInc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Increment the key of element i
This could crash if i exceeds the maxkey</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxChol.jl#L1276-L1279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.approxchol_lapChol-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.approxchol_lapChol-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.approxchol_lapChol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This variation of approxChol creates a cholesky factor to do the elimination. It has not yet been optimized, and does not yet make the cholesky factor lower triangular</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxChol.jl#L1121-L1124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.augmentTreeOpt-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti}" href="#Laplacians.augmentTreeOpt-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti}"><code>Laplacians.augmentTreeOpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">B = augmentTreeOpt{Tv,Ti}(tree, A, params)</code></pre><p>Takes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It uses cholmod to decide how many edge to add back, shooting for nnzL<em>fac times n entries in the factored augmented tree, with a number of flops to factor equal to nnz(a)*flops</em>fac. The edges to add back are then choen at random.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/augTreeSolver.jl#L85-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.blockSolver-Tuple{Any, Any}" href="#Laplacians.blockSolver-Tuple{Any, Any}"><code>Laplacians.blockSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply the ith solver on the ith component</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.complete_bipartite_graph_ijv-Tuple{Integer}" href="#Laplacians.complete_bipartite_graph_ijv-Tuple{Integer}"><code>Laplacians.complete_bipartite_graph_ijv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ijv = complete_bipartite_graph_ijv(n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphGenerators.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.complete_graph_ijv-Tuple{Integer}" href="#Laplacians.complete_graph_ijv-Tuple{Integer}"><code>Laplacians.complete_graph_ijv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ijv = complete_graph_ijv(n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphGenerators.jl#L55-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.empty_graph_ijv-Tuple{Integer}" href="#Laplacians.empty_graph_ijv-Tuple{Integer}"><code>Laplacians.empty_graph_ijv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ijv = empty_graph_ijv(n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphGenerators.jl#L7-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.extendMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, Vector{Tv}}} where {Tv, Ti}" href="#Laplacians.extendMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, Vector{Tv}}} where {Tv, Ti}"><code>Laplacians.extendMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a new vertex to a with weights to the other vertices corresponding to diagonal surplus weight.</p><p>This is an efficient way of writing [a d; d&#39; 0]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphOps.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.firstn-Tuple{Laplacians.IJV, Integer}" href="#Laplacians.firstn-Tuple{Laplacians.IJV, Integer}"><code>Laplacians.firstn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">b = firstn(a::IJV, n::Integer)</code></pre><p>Only keep the first n vertices of a.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphOps.jl#L566-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.forceLap-Tuple{AbstractArray}" href="#Laplacians.forceLap-Tuple{AbstractArray}"><code>Laplacians.forceLap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">la = forceLap(a)</code></pre><p>Create a Laplacian matrix from an adjacency matrix. If the input looks like a Laplacian, throw a warning and convert it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.generalizedNecklace-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC, Int64}} where {Tv, Ti}" href="#Laplacians.generalizedNecklace-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC, Int64}} where {Tv, Ti}"><code>Laplacians.generalizedNecklace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph = generalizedNecklace(A, H, k::Int64)</code></pre><p>Constructs a generalized necklace graph starting with two graphs A and H. The resulting new graph will be constructed by expanding each vertex in H to an instance of A. k random edges will be generated between components. Thus, the resulting graph may have weighted edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphOps.jl#L278-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.initDictCol!-Tuple{Any, Any, Any}" href="#Laplacians.initDictCol!-Tuple{Any, Any, Any}"><code>Laplacians.initDictCol!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initDictCol!(dic, name, typ)</code></pre><p>For a dictionary in which each key indexes an array. If dic does not contain an entry of <code>name</code>, create with set to <code>Array(typ,0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/compare_solvers.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.lapWrapComponents-Tuple{Any, AbstractArray}" href="#Laplacians.lapWrapComponents-Tuple{Any, AbstractArray}"><code>Laplacians.lapWrapComponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = lapWrapComponents(solver, a::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Applies a Laplacian <code>solver</code> that satisfies our interface to each connected component of the graph with adjacency matrix <code>a</code>. Passes kwargs on the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L202-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.lapWrapConnected-Tuple{Any, AbstractMatrix}" href="#Laplacians.lapWrapConnected-Tuple{Any, AbstractMatrix}"><code>Laplacians.lapWrapConnected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = lapWrapConnected(sddmSolver, a::AbstractMatrix; kwargs...)</code></pre><p>Applies a <code>sddmSolver</code> to the Laplacian of the adjacency matrix <code>a</code> of a connected graph. Passes on kwargs to the solver. <code>sddmSolver</code> should be a solver that obeys the interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.ldli2Chol-Tuple{Any}" href="#Laplacians.ldli2Chol-Tuple{Any}"><code>Laplacians.ldli2Chol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">L = ldli2Chol(ldli)</code></pre><p>This produces a matrix L so that L L^T approximate the original Laplacians. It is not quite a Cholesky factor, because it is off by a perm (and the all-1s vector orthogonality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxChol.jl#L1038-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.path_graph_ijv-Tuple{Integer}" href="#Laplacians.path_graph_ijv-Tuple{Integer}"><code>Laplacians.path_graph_ijv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ijv = path_graph_ijv(n::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphGenerators.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.print_ll_col-Tuple{Laplacians.LLMatOrd, Int64}" href="#Laplacians.print_ll_col-Tuple{Laplacians.LLMatOrd, Int64}"><code>Laplacians.print_ll_col</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Print a column in an LLMatOrd matrix.   This is here for diagnostics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxChol.jl#L174-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.print_ll_col-Tuple{Laplacians.LLmatp, Int64}" href="#Laplacians.print_ll_col-Tuple{Laplacians.LLmatp, Int64}"><code>Laplacians.print_ll_col</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Print a column in an LLmatp matrix.   This is here for diagnostics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/approxChol.jl#L99-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.pure_random_ijv-Tuple{Integer}" href="#Laplacians.pure_random_ijv-Tuple{Integer}"><code>Laplacians.pure_random_ijv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a = pure_random_ijv(n::Integer; verbose=false, prefix=&quot;&quot;, ver=Vcur)</code></pre><p>Chooses among path<em>graph, ring</em>graph, grid<em>graph, complete</em>binary<em>tree, rand</em>gen<em>ring, grown</em>graph and ErdosRenyiClusterFix. It can produce a disconnected graph. For code that always produces a connected graph (and is the same as with Julia v0.6, use pure<em>random</em>ijv_v6)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphGenerators.jl#L669-L675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.pushSpeedResult!-Tuple{Any, Any, Any}" href="#Laplacians.pushSpeedResult!-Tuple{Any, Any, Any}"><code>Laplacians.pushSpeedResult!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ret</code> is the answer returned by a speed test. This pushed it into the dictionary on which we are storing the tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/compare_solvers.jl#L39-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.rand_regular_bipartite-Tuple{Any, Any}" href="#Laplacians.rand_regular_bipartite-Tuple{Any, Any}"><code>Laplacians.rand_regular_bipartite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a = rand_regular_bipartite(n,k)</code></pre><p>Random k-regular bipartite graph between two sets of n vertices. No repeat edges, so can take a long time to build of k is close to n.</p><p>Returns a (possibly) asymmetric matrix that contains the upper-right block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/latinSquares.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.ring_graph_ijv-Tuple{Integer}" href="#Laplacians.ring_graph_ijv-Tuple{Integer}"><code>Laplacians.ring_graph_ijv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ijv = ring_graph_ijv(n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphGenerators.jl#L80-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.sampleByWeight-Tuple{Any}" href="#Laplacians.sampleByWeight-Tuple{Any}"><code>Laplacians.sampleByWeight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ind = sampleByWeight(wt; ver=Vcur)</code></pre><p>sample an index with probability proportional to its weight given here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphGenerators.jl#L731-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.sddmWrapLap-Tuple{Any, AbstractArray}" href="#Laplacians.sddmWrapLap-Tuple{Any, AbstractArray}"><code>Laplacians.sddmWrapLap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = sddmWrapLap(lapSolver, sddm::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Uses a <code>lapSolver</code> to solve systems of linear equations in sddm matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L304-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.sortSet-Union{Tuple{Ti}, Tuple{Vector{Ti}, Ti}} where Ti" href="#Laplacians.sortSet-Union{Tuple{Ti}, Tuple{Vector{Ti}, Ti}} where Ti"><code>Laplacians.sortSet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a set of integers, <code>set</code> between 1 and n, return a sorted version of them</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/fastCSC.jl#L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.star_graph_ijv-Tuple{Integer}" href="#Laplacians.star_graph_ijv-Tuple{Integer}"><code>Laplacians.star_graph_ijv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ijv = star_graph_ijv(n::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphGenerators.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.testZeroDiag-Tuple{Any}" href="#Laplacians.testZeroDiag-Tuple{Any}"><code>Laplacians.testZeroDiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">testZeroDiag(a)</code></pre><p>Returns true if <code>a</code> has zero diagonal, false otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.treeDepthDFS-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Laplacians.treeDepthDFS-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Laplacians.treeDepthDFS</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the vector of depths in a tree that is in DFS order, <em>with the root at the first position, and the leaves at the end</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/treeAlgs.jl#L391-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.uniformWeight_ver-Tuple{Type{Val{6}}, SparseArrays.SparseMatrixCSC}" href="#Laplacians.uniformWeight_ver-Tuple{Type{Val{6}}, SparseArrays.SparseMatrixCSC}"><code>Laplacians.uniformWeight_ver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wted = uniformWeight(unwted)</code></pre><p>Put a uniform [0,1] weight on every edge.  This is an example of how to use mapweight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/graphOps.jl#L121-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.wrapCapture-Tuple{Function, Any, Any}" href="#Laplacians.wrapCapture-Tuple{Function, Any, Any}"><code>Laplacians.wrapCapture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = wrapCapture(solver::Function, mats, rhss; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>This wraps a solver so that we can capture all the matrices that it solves and all the right-hand-sides. Those are pushed into the arrays <code>mats</code> and <code>rhss</code>. For example</p><pre><code class="language-julia">julia&gt; mats = []
julia&gt; rhss = []
julia&gt; solver = wrapCapture(approxchol_lap, mats, rhss)
julia&gt; a = chimera(10)
julia&gt; f = solver(a);
julia&gt; size(mats[1])
(10,10)
julia&gt; b = randn(10)
julia&gt; x = f(b);
julia&gt; rhss
1-element Array{Any,1}:
 [0.404962,-0.827718,0.704616,-0.403223,0.204891,-0.505589,0.907015,1.90266,-0.438115,0.0464351]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L377-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.wrapCaptureRhs-Tuple{Function, Any}" href="#Laplacians.wrapCaptureRhs-Tuple{Function, Any}"><code>Laplacians.wrapCaptureRhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = wrapCaptureRhs(sola::Function, rhss; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Captures all the right-hand-sides that are passed to the solver <code>sola</code>.  It pushes them into an array called rhhs. For example</p><pre><code class="language-julia">julia&gt; rhss = []
julia&gt; a = wted_chimera(100)
julia&gt; sola = approxchol_lap(a)
julia&gt; wrappedSolver = wrapCaptureRhs(sola,rhss)
julia&gt; b = randn(100)
julia&gt; x = wrappedSolver(b,verbose=true)

PCG BLAS stopped after: 0.0 seconds and 11 iterations with relative error 3.160275810360986e-7.

julia&gt; length(rhss[1])

100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L341-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Laplacians.wrapInterface-Tuple{Function, AbstractMatrix}" href="#Laplacians.wrapInterface-Tuple{Function, AbstractMatrix}"><code>Laplacians.wrapInterface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solveA = wrapInterface(solver::Function, A::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[],params...)
solverConstructor = wrapInterface(A::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[],params...)</code></pre><p>Returns a function that discards <code>tol</code>, <code>maxits</code>, <code>maxtime</code> and <code>verbose</code>, sets <code>pcgIts</code> to 0 (because it might not be using pcg), and passes whatever <code>params</code> are left to the solver.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; a = randn(5,5);
julia&gt; a = a * a&#39;;
julia&gt; solvea = wrapInterface(X-&gt;cholesky(X,Val(true)), a, maxits=100, verbose=true);
julia&gt; b = randn(5,1);
julia&gt; norm(a*solvea(b, verbose=false)-b)
1.575705319704736e-14

julia&gt; f = wrapInterface(X-&gt;cholesky(X,Val(true)))
julia&gt; solvea = f(a, maxits=1000, maxtime = 1)
julia&gt; norm(a*solvea(b, verbose=false, maxtime = 10)-b)
1.575705319704736e-14</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/8d851a8e8efbb34ffe97f47258a4b2cb5ae91993/src/solverInterface.jl#L10-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../localClustering/">« localClustering</a><a class="docs-footer-nextpage" href="../indexOfAll/">All of the above »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 1 June 2022 13:59">Wednesday 1 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
