<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Private Functions · Laplacians.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Laplacians.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">About</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../Installation/">Installation</a></li><li><a class="toctext" href="../Examples/">Examples</a></li><li><a class="toctext" href="../CSCgraph/">Sparse matrices as graphs</a></li><li><a class="toctext" href="../usingSolvers/">Solving Linear Equations</a></li><li><a class="toctext" href="../LSST/">Low Stretch Spanning Trees</a></li></ul></li><li><a class="toctext" href="../Developing/">Developing</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../graphGenerators/">generators</a></li><li><a class="toctext" href="../operators/">operators</a></li><li><a class="toctext" href="../graphUtils/">graphUtils</a></li><li><a class="toctext" href="../graphAlgs/">graphAlgs</a></li><li><a class="toctext" href="../IO/">IO</a></li><li><a class="toctext" href="../solvers/">solvers</a></li><li><a class="toctext" href="../sparsification/">sparsification</a></li><li><a class="toctext" href="../akpw/">akpw</a></li><li><a class="toctext" href="../treeAlgs/">treeAlgs</a></li><li><a class="toctext" href="../randTrees/">randTrees</a></li><li><a class="toctext" href="../localClustering/">localClustering</a></li><li class="current"><a class="toctext" href>Private Functions</a><ul class="internal"></ul></li><li><a class="toctext" href="../indexOfAll/">All of the above</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>Private Functions</a></li></ul><a class="edit-page" href="https://github.com/danspielman/Laplacians.jl/blob/master/docs/src/privateFuncs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Private Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Unexported-(Private)-functions.-1" href="#Unexported-(Private)-functions.-1">Unexported (Private) functions.</a></h1><p>This is a list of all unexported functions and types from Laplacians.</p><ul><li><a href="#Laplacians.ApproxCholPQ"><code>Laplacians.ApproxCholPQ</code></a></li><li><a href="#Laplacians.IJV-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.IJV</code></a></li><li><a href="#Laplacians.LDLinv"><code>Laplacians.LDLinv</code></a></li><li><a href="#Laplacians.LLmatp"><code>Laplacians.LLmatp</code></a></li><li><a href="#Laplacians.LLp"><code>Laplacians.LLp</code></a></li><li><a href="#Laplacians.addToGPrime-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Array{Tuple{Int64,Float64},1},1},Dict{Int64,Int64},Dict{Int64,Int64},Int64,Int64,Float64,Float64,Int64}} where Ti where Tv"><code>Laplacians.addToGPrime</code></a></li><li><a href="#Laplacians.approxCholPQDec!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind},Any}} where Tind"><code>Laplacians.approxCholPQDec!</code></a></li><li><a href="#Laplacians.approxCholPQInc!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind},Any}} where Tind"><code>Laplacians.approxCholPQInc!</code></a></li><li><a href="#Laplacians.approxchol_lapChol-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.approxchol_lapChol</code></a></li><li><a href="#Laplacians.augmentTreeOpt-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},SparseArrays.SparseMatrixCSC{Tv,Ti}}} where Ti where Tv"><code>Laplacians.augmentTreeOpt</code></a></li><li><a href="#Laplacians.blockSolver-Tuple{Any,Any}"><code>Laplacians.blockSolver</code></a></li><li><a href="#Laplacians.complete_bipartite_graph_ijv-Tuple{Integer}"><code>Laplacians.complete_bipartite_graph_ijv</code></a></li><li><a href="#Laplacians.complete_graph_ijv-Tuple{Integer}"><code>Laplacians.complete_graph_ijv</code></a></li><li><a href="#Laplacians.empty_graph_ijv-Tuple{Integer}"><code>Laplacians.empty_graph_ijv</code></a></li><li><a href="#Laplacians.extendMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Tv,1}}} where Ti where Tv"><code>Laplacians.extendMatrix</code></a></li><li><a href="#Laplacians.firstn-Tuple{Laplacians.IJV,Integer}"><code>Laplacians.firstn</code></a></li><li><a href="#Laplacians.forceLap-Tuple{AbstractArray}"><code>Laplacians.forceLap</code></a></li><li><a href="#Laplacians.generalizedNecklace-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},SparseArrays.SparseMatrixCSC,Int64}} where Ti where Tv"><code>Laplacians.generalizedNecklace</code></a></li><li><a href="#Laplacians.getCutSet-Tuple{Array{Array{Tuple{Int64,Float64},1},1},Int64,Int64}"><code>Laplacians.getCutSet</code></a></li><li><a href="#Laplacians.initDictCol!-Tuple{Any,Any,Any}"><code>Laplacians.initDictCol!</code></a></li><li><a href="#Laplacians.initGPrime-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Dict{Int64,Int64},Dict{Int64,Int64},Float64,Int64}} where Ti where Tv"><code>Laplacians.initGPrime</code></a></li><li><a href="#Laplacians.lapWrapComponents-Tuple{Any,AbstractArray}"><code>Laplacians.lapWrapComponents</code></a></li><li><a href="#Laplacians.lapWrapConnected-Tuple{Any,AbstractArray{T,2} where T}"><code>Laplacians.lapWrapConnected</code></a></li><li><a href="#Laplacians.ldli2Chol-Tuple{Any}"><code>Laplacians.ldli2Chol</code></a></li><li><a href="#Laplacians.localBlockFlow-Tuple{Array{Array{Tuple{Int64,Float64},1},1},Int64,Int64}"><code>Laplacians.localBlockFlow</code></a></li><li><a href="#Laplacians.localFlow-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64,Any}} where Ti where Tv"><code>Laplacians.localFlow</code></a></li><li><a href="#Laplacians.path_graph_ijv-Tuple{Integer}"><code>Laplacians.path_graph_ijv</code></a></li><li><a href="#Laplacians.print_ll_col-Tuple{Laplacians.LLMatOrd,Int64}"><code>Laplacians.print_ll_col</code></a></li><li><a href="#Laplacians.print_ll_col-Tuple{Laplacians.LLmatp,Int64}"><code>Laplacians.print_ll_col</code></a></li><li><a href="#Laplacians.pure_random_ijv-Tuple{Integer}"><code>Laplacians.pure_random_ijv</code></a></li><li><a href="#Laplacians.pushSpeedResult!-Tuple{Any,Any,Any}"><code>Laplacians.pushSpeedResult!</code></a></li><li><a href="#Laplacians.rand_regular_bipartite-Tuple{Any,Any}"><code>Laplacians.rand_regular_bipartite</code></a></li><li><a href="#Laplacians.ring_graph_ijv-Tuple{Integer}"><code>Laplacians.ring_graph_ijv</code></a></li><li><a href="#Laplacians.sampleByWeight-Tuple{Any}"><code>Laplacians.sampleByWeight</code></a></li><li><a href="#Laplacians.sddmWrapLap-Tuple{Any,AbstractArray}"><code>Laplacians.sddmWrapLap</code></a></li><li><a href="#Laplacians.sortSet-Union{Tuple{Ti}, Tuple{Array{Ti,1},Ti}} where Ti"><code>Laplacians.sortSet</code></a></li><li><a href="#Laplacians.star_graph_ijv-Tuple{Integer}"><code>Laplacians.star_graph_ijv</code></a></li><li><a href="#Laplacians.testZeroDiag-Tuple{Any}"><code>Laplacians.testZeroDiag</code></a></li><li><a href="#Laplacians.treeDepthDFS-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.treeDepthDFS</code></a></li><li><a href="#Laplacians.uniformWeight_ver-Tuple{Type{Val{6}},SparseArrays.SparseMatrixCSC}"><code>Laplacians.uniformWeight_ver</code></a></li><li><a href="#Laplacians.wrapCapture-Tuple{Function,Any,Any}"><code>Laplacians.wrapCapture</code></a></li><li><a href="#Laplacians.wrapCaptureRhs-Tuple{Function,Any}"><code>Laplacians.wrapCaptureRhs</code></a></li><li><a href="#Laplacians.wrapInterface-Tuple{Function,AbstractArray{T,2} where T}"><code>Laplacians.wrapInterface</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ApproxCholPQ" href="#Laplacians.ApproxCholPQ"><code>Laplacians.ApproxCholPQ</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An approximate priority queue.   Items are bundled together into doubly-linked lists with all approximately the same key.   minlist is the min list we know to be non-empty.   It should always be a lower bound.   keyMap maps keys to lists</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxCholTypes.jl#L94-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.IJV-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.IJV-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.IJV</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ijv = IJV(A::SparseMatrixCSC)</code></pre><p>Convert a sparse matrix to an IJV.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/IJV.jl#L55-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.LDLinv" href="#Laplacians.LDLinv"><code>Laplacians.LDLinv</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>LDLinv contains the information needed to solve the Laplacian systems.   It does it by applying Linv, then Dinv, then Linv (transpose).   But, it is specially constructed for this particular solver.   It does not explicitly make the matrix triangular.   Rather, col[i] is the name of the ith col to be eliminated</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxCholTypes.jl#L66-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.LLmatp" href="#Laplacians.LLmatp"><code>Laplacians.LLmatp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>LLmatp is the data structure used to maintain the matrix during elimination.   It stores the elements in each column in a singly linked list (only next ptrs)   Each element is an LLp (linked list pointer).   The head of each column is pointed to by cols.</p><p>We probably can get rid of degs - as it is only used to store initial degrees.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxCholTypes.jl#L26-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.LLp" href="#Laplacians.LLp"><code>Laplacians.LLp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>LLp elements are all in the same column.   row tells us the row, and val is the entry.   val is set to zero for some edges that we should remove.   next gives the next in the column.  It points to itself to terminate.   reverse is the index into lles of the other copy of this edge,   since every edge is stored twice as we do not know the order of elimination in advance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxCholTypes.jl#L6-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.addToGPrime-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Array{Tuple{Int64,Float64},1},1},Dict{Int64,Int64},Dict{Int64,Int64},Int64,Int64,Float64,Float64,Int64}} where Ti where Tv" href="#Laplacians.addToGPrime-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Array{Tuple{Int64,Float64},1},1},Dict{Int64,Int64},Dict{Int64,Int64},Int64,Int64,Float64,Float64,Int64}} where Ti where Tv"><code>Laplacians.addToGPrime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add a new vertex to GPrime </p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/localClustering.jl#L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxCholPQDec!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind},Any}} where Tind" href="#Laplacians.approxCholPQDec!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind},Any}} where Tind"><code>Laplacians.approxCholPQDec!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Decrement the key of element i
This could crash if i exceeds the maxkey</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxChol.jl#L1251-L1254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxCholPQInc!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind},Any}} where Tind" href="#Laplacians.approxCholPQInc!-Union{Tuple{Tind}, Tuple{Laplacians.ApproxCholPQ{Tind},Any}} where Tind"><code>Laplacians.approxCholPQInc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Increment the key of element i
This could crash if i exceeds the maxkey</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxChol.jl#L1276-L1279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.approxchol_lapChol-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.approxchol_lapChol-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.approxchol_lapChol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This variation of approxChol creates a cholesky factor to do the elimination. It has not yet been optimized, and does not yet make the cholesky factor lower triangular</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxChol.jl#L1121-L1124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.augmentTreeOpt-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},SparseArrays.SparseMatrixCSC{Tv,Ti}}} where Ti where Tv" href="#Laplacians.augmentTreeOpt-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},SparseArrays.SparseMatrixCSC{Tv,Ti}}} where Ti where Tv"><code>Laplacians.augmentTreeOpt</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">B = augmentTreeOpt{Tv,Ti}(tree, A, params)</code></pre><p>Takes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It uses cholmod to decide how many edge to add back, shooting for nnzL<em>fac times n entries in the factored augmented tree, with a number of flops to factor equal to nnz(a)*flops</em>fac. The edges to add back are then choen at random.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/augTreeSolver.jl#L85-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.blockSolver-Tuple{Any,Any}" href="#Laplacians.blockSolver-Tuple{Any,Any}"><code>Laplacians.blockSolver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Apply the ith solver on the ith component</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.complete_bipartite_graph_ijv-Tuple{Integer}" href="#Laplacians.complete_bipartite_graph_ijv-Tuple{Integer}"><code>Laplacians.complete_bipartite_graph_ijv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ijv = complete_bipartite_graph_ijv(n)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphGenerators.jl#L68-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.complete_graph_ijv-Tuple{Integer}" href="#Laplacians.complete_graph_ijv-Tuple{Integer}"><code>Laplacians.complete_graph_ijv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ijv = complete_graph_ijv(n)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphGenerators.jl#L55-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.empty_graph_ijv-Tuple{Integer}" href="#Laplacians.empty_graph_ijv-Tuple{Integer}"><code>Laplacians.empty_graph_ijv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ijv = empty_graph_ijv(n)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphGenerators.jl#L7-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.extendMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Tv,1}}} where Ti where Tv" href="#Laplacians.extendMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Tv,1}}} where Ti where Tv"><code>Laplacians.extendMatrix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Add a new vertex to a with weights to the other vertices corresponding to diagonal surplus weight.</p><p>This is an efficient way of writing [a d; d&#39; 0]</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphOps.jl#L44-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.firstn-Tuple{Laplacians.IJV,Integer}" href="#Laplacians.firstn-Tuple{Laplacians.IJV,Integer}"><code>Laplacians.firstn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">b = firstn(a::IJV, n::Integer)</code></pre><p>Only keep the first n vertices of a.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphOps.jl#L566-L570">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.forceLap-Tuple{AbstractArray}" href="#Laplacians.forceLap-Tuple{AbstractArray}"><code>Laplacians.forceLap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">la = forceLap(a)</code></pre><p>Create a Laplacian matrix from an adjacency matrix. If the input looks like a Laplacian, throw a warning and convert it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L82-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.generalizedNecklace-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},SparseArrays.SparseMatrixCSC,Int64}} where Ti where Tv" href="#Laplacians.generalizedNecklace-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},SparseArrays.SparseMatrixCSC,Int64}} where Ti where Tv"><code>Laplacians.generalizedNecklace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">graph = generalizedNecklace(A, H, k::Int64)</code></pre><p>Constructs a generalized necklace graph starting with two graphs A and H. The resulting new graph will be constructed by expanding each vertex in H to an instance of A. k random edges will be generated between components. Thus, the resulting graph may have weighted edges.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphOps.jl#L278-L285">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.getCutSet-Tuple{Array{Array{Tuple{Int64,Float64},1},1},Int64,Int64}" href="#Laplacians.getCutSet-Tuple{Array{Array{Tuple{Int64,Float64},1},1},Int64,Int64}"><code>Laplacians.getCutSet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the min cut from the source - return all vertices in the cut besides the source </p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/localClustering.jl#L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.initDictCol!-Tuple{Any,Any,Any}" href="#Laplacians.initDictCol!-Tuple{Any,Any,Any}"><code>Laplacians.initDictCol!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">initDictCol!(dic, name, typ)</code></pre><p>For a dictionary in which each key indexes an array. If dic does not contain an entry of <code>name</code>, create with set to <code>Array(typ,0)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/compare_solvers.jl#L25-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.initGPrime-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Dict{Int64,Int64},Dict{Int64,Int64},Float64,Int64}} where Ti where Tv" href="#Laplacians.initGPrime-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Dict{Int64,Int64},Dict{Int64,Int64},Float64,Int64}} where Ti where Tv"><code>Laplacians.initGPrime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Initialize GPrime with the set A and edges of type s-&gt;u</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/localClustering.jl#L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.lapWrapComponents-Tuple{Any,AbstractArray}" href="#Laplacians.lapWrapComponents-Tuple{Any,AbstractArray}"><code>Laplacians.lapWrapComponents</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">f = lapWrapComponents(solver, a::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Applies a Laplacian <code>solver</code> that satisfies our interface to each connected component of the graph with adjacency matrix <code>a</code>. Passes kwargs on the solver.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L202-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.lapWrapConnected-Tuple{Any,AbstractArray{T,2} where T}" href="#Laplacians.lapWrapConnected-Tuple{Any,AbstractArray{T,2} where T}"><code>Laplacians.lapWrapConnected</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">f = lapWrapConnected(sddmSolver, a::AbstractMatrix; kwargs...)</code></pre><p>Applies a <code>sddmSolver</code> to the Laplacian of the adjacency matrix <code>a</code> of a connected graph. Passes on kwargs to the solver. <code>sddmSolver</code> should be a solver that obeys the interface.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L105-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ldli2Chol-Tuple{Any}" href="#Laplacians.ldli2Chol-Tuple{Any}"><code>Laplacians.ldli2Chol</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">L = ldli2Chol(ldli)</code></pre><p>This produces a matrix L so that L L^T approximate the original Laplacians. It is not quite a Cholesky factor, because it is off by a perm (and the all-1s vector orthogonality.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxChol.jl#L1038-L1043">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.localBlockFlow-Tuple{Array{Array{Tuple{Int64,Float64},1},1},Int64,Int64}" href="#Laplacians.localBlockFlow-Tuple{Array{Array{Tuple{Int64,Float64},1},1},Int64,Int64}"><code>Laplacians.localBlockFlow</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Compute block flow between s and t</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/localClustering.jl#L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.localFlow-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64,Any}} where Ti where Tv" href="#Laplacians.localFlow-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64,Any}} where Ti where Tv"><code>Laplacians.localFlow</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The LocalFlow function, from the Orecchia-Zhu paper </p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/localClustering.jl#L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.path_graph_ijv-Tuple{Integer}" href="#Laplacians.path_graph_ijv-Tuple{Integer}"><code>Laplacians.path_graph_ijv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ijv = path_graph_ijv(n::Int64)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphGenerators.jl#L23-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.print_ll_col-Tuple{Laplacians.LLMatOrd,Int64}" href="#Laplacians.print_ll_col-Tuple{Laplacians.LLMatOrd,Int64}"><code>Laplacians.print_ll_col</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Print a column in an LLMatOrd matrix.   This is here for diagnostics.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxChol.jl#L174-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.print_ll_col-Tuple{Laplacians.LLmatp,Int64}" href="#Laplacians.print_ll_col-Tuple{Laplacians.LLmatp,Int64}"><code>Laplacians.print_ll_col</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Print a column in an LLmatp matrix.   This is here for diagnostics.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/approxChol.jl#L99-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pure_random_ijv-Tuple{Integer}" href="#Laplacians.pure_random_ijv-Tuple{Integer}"><code>Laplacians.pure_random_ijv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">a = pure_random_ijv(n::Integer; verbose=false, prefix=&quot;&quot;, ver=Vcur)</code></pre><p>Chooses among path<em>graph, ring</em>graph, grid<em>graph, complete</em>binary<em>tree, rand</em>gen<em>ring, grown</em>graph and ErdosRenyiClusterFix. It can produce a disconnected graph. For code that always produces a connected graph (and is the same as with Julia v0.6, use pure<em>random</em>ijv_v6)</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphGenerators.jl#L669-L675">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.pushSpeedResult!-Tuple{Any,Any,Any}" href="#Laplacians.pushSpeedResult!-Tuple{Any,Any,Any}"><code>Laplacians.pushSpeedResult!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>ret</code> is the answer returned by a speed test. This pushed it into the dictionary on which we are storing the tests.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/compare_solvers.jl#L39-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.rand_regular_bipartite-Tuple{Any,Any}" href="#Laplacians.rand_regular_bipartite-Tuple{Any,Any}"><code>Laplacians.rand_regular_bipartite</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">a = rand_regular_bipartite(n,k)</code></pre><p>Random k-regular bipartite graph between two sets of n vertices. No repeat edges, so can take a long time to build of k is close to n.</p><p>Returns a (possibly) asymmetric matrix that contains the upper-right block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/latinSquares.jl#L1-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.ring_graph_ijv-Tuple{Integer}" href="#Laplacians.ring_graph_ijv-Tuple{Integer}"><code>Laplacians.ring_graph_ijv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ijv = ring_graph_ijv(n)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphGenerators.jl#L80-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.sampleByWeight-Tuple{Any}" href="#Laplacians.sampleByWeight-Tuple{Any}"><code>Laplacians.sampleByWeight</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ind = sampleByWeight(wt; ver=Vcur)</code></pre><p>sample an index with probability proportional to its weight given here</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphGenerators.jl#L731-L735">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.sddmWrapLap-Tuple{Any,AbstractArray}" href="#Laplacians.sddmWrapLap-Tuple{Any,AbstractArray}"><code>Laplacians.sddmWrapLap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">f = sddmWrapLap(lapSolver, sddm::AbstractArray; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Uses a <code>lapSolver</code> to solve systems of linear equations in sddm matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L304-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.sortSet-Union{Tuple{Ti}, Tuple{Array{Ti,1},Ti}} where Ti" href="#Laplacians.sortSet-Union{Tuple{Ti}, Tuple{Array{Ti,1},Ti}} where Ti"><code>Laplacians.sortSet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Given a set of integers, <code>set</code> between 1 and n, return a sorted version of them</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/fastCSC.jl#L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.star_graph_ijv-Tuple{Integer}" href="#Laplacians.star_graph_ijv-Tuple{Integer}"><code>Laplacians.star_graph_ijv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ijv = star_graph_ijv(n::Int64)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphGenerators.jl#L38-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.testZeroDiag-Tuple{Any}" href="#Laplacians.testZeroDiag-Tuple{Any}"><code>Laplacians.testZeroDiag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">testZeroDiag(a)</code></pre><p>Returns true if <code>a</code> has zero diagonal, false otherwise</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L186-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.treeDepthDFS-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv" href="#Laplacians.treeDepthDFS-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti}}, Tuple{Ti}, Tuple{Tv}} where Ti where Tv"><code>Laplacians.treeDepthDFS</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Compute the vector of depths in a tree that is in DFS order, <em>with the root at the first position, and the leaves at the end</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/treeAlgs.jl#L391-L394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.uniformWeight_ver-Tuple{Type{Val{6}},SparseArrays.SparseMatrixCSC}" href="#Laplacians.uniformWeight_ver-Tuple{Type{Val{6}},SparseArrays.SparseMatrixCSC}"><code>Laplacians.uniformWeight_ver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">wted = uniformWeight(unwted)</code></pre><p>Put a uniform [0,1] weight on every edge.  This is an example of how to use mapweight.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/graphOps.jl#L121-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wrapCapture-Tuple{Function,Any,Any}" href="#Laplacians.wrapCapture-Tuple{Function,Any,Any}"><code>Laplacians.wrapCapture</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">f = wrapCapture(solver::Function, mats, rhss; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>This wraps a solver so that we can capture all the matrices that it solves and all the right-hand-sides. Those are pushed into the arrays <code>mats</code> and <code>rhss</code>. For example</p><pre><code class="language-julia">julia&gt; mats = []
julia&gt; rhss = []
julia&gt; solver = wrapCapture(approxchol_lap, mats, rhss)
julia&gt; a = chimera(10)
julia&gt; f = solver(a);
julia&gt; size(mats[1])
(10,10)
julia&gt; b = randn(10)
julia&gt; x = f(b);
julia&gt; rhss
1-element Array{Any,1}:
 [0.404962,-0.827718,0.704616,-0.403223,0.204891,-0.505589,0.907015,1.90266,-0.438115,0.0464351]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L377-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wrapCaptureRhs-Tuple{Function,Any}" href="#Laplacians.wrapCaptureRhs-Tuple{Function,Any}"><code>Laplacians.wrapCaptureRhs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">f = wrapCaptureRhs(sola::Function, rhss; tol::Real=1e-6, maxits=Inf, maxtime=Inf, verbose=false, pcgIts=Int[], params...)</code></pre><p>Captures all the right-hand-sides that are passed to the solver <code>sola</code>.  It pushes them into an array called rhhs. For example</p><pre><code class="language-julia">julia&gt; rhss = []
julia&gt; a = wted_chimera(100)
julia&gt; sola = approxchol_lap(a)
julia&gt; wrappedSolver = wrapCaptureRhs(sola,rhss)
julia&gt; b = randn(100)
julia&gt; x = wrappedSolver(b,verbose=true)

PCG BLAS stopped after: 0.0 seconds and 11 iterations with relative error 3.160275810360986e-7.

julia&gt; length(rhss[1])

100</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L341-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.wrapInterface-Tuple{Function,AbstractArray{T,2} where T}" href="#Laplacians.wrapInterface-Tuple{Function,AbstractArray{T,2} where T}"><code>Laplacians.wrapInterface</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">solveA = wrapInterface(solver::Function, A::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[],params...)
solverConstructor = wrapInterface(A::AbstractMatrix; tol, maxits, maxtime, verbose, pcgIts=Int[],params...)</code></pre><p>Returns a function that discards <code>tol</code>, <code>maxits</code>, <code>maxtime</code> and <code>verbose</code>, sets <code>pcgIts</code> to 0 (because it might not be using pcg), and passes whatever <code>params</code> are left to the solver.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; a = randn(5,5);
julia&gt; a = a * a&#39;;
julia&gt; solvea = wrapInterface(X-&gt;cholesky(X,Val(true)), a, maxits=100, verbose=true);
julia&gt; b = randn(5,1);
julia&gt; norm(a*solvea(b, verbose=false)-b)
1.575705319704736e-14

julia&gt; f = wrapInterface(X-&gt;cholesky(X,Val(true)))
julia&gt; solvea = f(a, maxits=1000, maxtime = 1)
julia&gt; norm(a*solvea(b, verbose=false, maxtime = 10)-b)
1.575705319704736e-14</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/fa710e465aac7eaeaea32df3c0752f0c762cf9a3/src/solverInterface.jl#L10-L33">source</a></section><footer><hr/><a class="previous" href="../localClustering/"><span class="direction">Previous</span><span class="title">localClustering</span></a><a class="next" href="../indexOfAll/"><span class="direction">Next</span><span class="title">All of the above</span></a></footer></article></body></html>
