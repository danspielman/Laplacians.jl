<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>localClustering · Laplacians.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Laplacians.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">About</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../Installation/">Installation</a></li><li><a class="toctext" href="../Examples/">Examples</a></li><li><a class="toctext" href="../CSCgraph/">Sparse matrices as graphs</a></li><li><a class="toctext" href="../usingSolvers/">Solving Linear Equations</a></li><li><a class="toctext" href="../LSST/">Low Stretch Spanning Trees</a></li></ul></li><li><a class="toctext" href="../Developing/">Developing</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../graphGenerators/">generators</a></li><li><a class="toctext" href="../operators/">operators</a></li><li><a class="toctext" href="../graphUtils/">graphUtils</a></li><li><a class="toctext" href="../graphAlgs/">graphAlgs</a></li><li><a class="toctext" href="../IO/">IO</a></li><li><a class="toctext" href="../solvers/">solvers</a></li><li><a class="toctext" href="../sparsification/">sparsification</a></li><li><a class="toctext" href="../akpw/">akpw</a></li><li><a class="toctext" href="../treeAlgs/">treeAlgs</a></li><li><a class="toctext" href="../randTrees/">randTrees</a></li><li class="current"><a class="toctext" href>localClustering</a><ul class="internal"></ul></li><li><a class="toctext" href="../privateFuncs/">Private Functions</a></li><li><a class="toctext" href="../indexOfAll/">All of the above</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>localClustering</a></li></ul><a class="edit-page" href="https://github.com/danspielman/Laplacians.jl/blob/master/docs/src/localClustering.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>localClustering</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Local-Clustering-1" href="#Local-Clustering-1">Local Clustering</a></h1><p>This is a collection of clustering related algorithms,   based on Approximate Personal PageRank, and improvement by local   flow computations.   It needs more documentation.</p><p>For now, see the <a href="https://github.com/danspielman/Laplacians.jl/blob/master/notebooks/LocalClustering.ipynb">Local Clustering Notebook</a></p><ul><li><a href="#Laplacians.apr-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64}} where Ti where Tv"><code>Laplacians.apr</code></a></li><li><a href="#Laplacians.dumbRefineCut-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv"><code>Laplacians.dumbRefineCut</code></a></li><li><a href="#Laplacians.localImprove-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv"><code>Laplacians.localImprove</code></a></li><li><a href="#Laplacians.prn-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Int64}} where Ti where Tv"><code>Laplacians.prn</code></a></li><li><a href="#Laplacians.refineCut-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv"><code>Laplacians.refineCut</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.dumbRefineCut-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv" href="#Laplacians.dumbRefineCut-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv"><code>Laplacians.dumbRefineCut</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Modify a cluster by passing through all the vertices exactly once and 
adding/removing them based on the value of (Deg_external - Deg_Internal).</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/b835233a9a58df690fd52d8546a1e1be49b40b02/src/cutHeuristics.jl#L100-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.refineCut-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv" href="#Laplacians.refineCut-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv"><code>Laplacians.refineCut</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Modify a cluster by adding or removing vertices by picking at each step 
the vertex that has the maximum value of (Deg_external - Deg_Internal).
Each vertex can be added in/removed only once.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/b835233a9a58df690fd52d8546a1e1be49b40b02/src/cutHeuristics.jl#L2-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.apr-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64}} where Ti where Tv" href="#Laplacians.apr-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Float64}} where Ti where Tv"><code>Laplacians.apr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Computes an approximate page rank vector from a starting set s, an alpha and an epsilon The algorithm follows the Anderson,Chung,Lang paper and Dan Spielman&#39;s lecture notes</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/b835233a9a58df690fd52d8546a1e1be49b40b02/src/localClustering.jl#L432-L436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.localImprove-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv" href="#Laplacians.localImprove-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1}}} where Ti where Tv"><code>Laplacians.localImprove</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">localImprove{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, A::Array{Int64,1}; epsSigma=-1.0, err=1e-10, maxSize = max(G.n, G.m)</code></pre><p>The LocalImprove function, from the Orrechia-Zhu paper. Given a graph and an initial set, finds a set of smaller conductance based on the starting set using a localized version of max-flow.</p><p>Small discussion: When adding in the neighbors of the initial component, if the resulting  conductance is worse than the initial one,  the algorithm will add more and more vertices until hitting a better conductance. However, if we fix a certain  maximum size for our component,  it might be the case that this new conductance will always be worse than what we had initially. Thus, if we run the algorithm with a small maxSize,  our initial conductance might be the best solution we can raech.</p><ul><li>G is the given graph, A is the initial set </li><li>epsSigma is a measure of the quality of the returning set (the smaller the better). It&#39;s defaulted to volume(A) / volume(V - A)</li><li>err is the numerical error considered throughout the algorithm. It&#39;s defaulted to 1e-10</li><li>maxSize is the maximum allowed size for the flow graph at any iteration of the algorithm. It&#39;s defaulted to |V|</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/b835233a9a58df690fd52d8546a1e1be49b40b02/src/localClustering.jl#L1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Laplacians.prn-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Int64}} where Ti where Tv" href="#Laplacians.prn-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Array{Int64,1},Float64,Int64}} where Ti where Tv"><code>Laplacians.prn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>prn{Tv, Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1}, phi::Float64, b::Int64)</p><p>The PageRank-Nibble cutting algorithm from the Anderson/Chung/Lang paper</p><p>s is a set of starting vertices, phi is a constant in (0, 1], and b is an integer in [1, [log m]]</p><p>phi is a bound on the quality of the conductance of the cut - the smaller the phi, the higher the quality.  b is used to handle precision throughout the algorithm - the higher the b, the greater the precision.</p></div></div><a class="source-link" target="_blank" href="https://github.com/danspielman/Laplacians.jl/blob/b835233a9a58df690fd52d8546a1e1be49b40b02/src/localClustering.jl#L363-L372">source</a></section><footer><hr/><a class="previous" href="../randTrees/"><span class="direction">Previous</span><span class="title">randTrees</span></a><a class="next" href="../privateFuncs/"><span class="direction">Next</span><span class="title">Private Functions</span></a></footer></article></body></html>
