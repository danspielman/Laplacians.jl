<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../lambda2.ico">
        

	<title>Whole API - Laplacians.jl</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../Laplacians.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="../about/index.html">Laplacians.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../about/index.html">About</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../Installation/index.html">Installation</a>
</li>

                        
                            
<li >
    <a href="../Julia/index.html">Using Julia</a>
</li>

                        
                            
<li >
    <a href="../Examples/index.html">Examples</a>
</li>

                        
                            
<li >
    <a href="../CSCgraph/index.html">Sparse matrices as graphs</a>
</li>

                        
                            
<li >
    <a href="../solvers/index.html">Solvers</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Developing <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../Developing/index.html">Devleoping Laplacians</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">API <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="index.html">Whole API</a>
</li>

                        
                            
<li >
    <a href="../graphGeneratorsAPI/index.html">graphGenerators</a>
</li>

                        
                            
<li >
    <a href="../IOAPI/index.html">IO</a>
</li>

                        
                            
<li >
    <a href="../graphOpsAPI/index.html">graphOps</a>
</li>

                        
                            
<li >
    <a href="../graphAlgsAPI/index.html">graphAlgs</a>
</li>

                        
                            
<li >
    <a href="../graphUtilsAPI/index.html">graphUtils</a>
</li>

                        
                            
<li >
    <a href="../solversAPI/index.html">solvers</a>
</li>

                        
                            
<li >
    <a href="../cutHeuristicsAPI/index.html">cutHeuristics</a>
</li>

                        
                            
<li >
    <a href="../localClusteringAPI/index.html">localClustering</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../Developing/index.html">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../graphGeneratorsAPI/index.html">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/danspielman/Laplacians.jl">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#erdosrenyi">ErdosRenyi</a></li>
        
    
        <li class="main "><a href="#erdosrenyicluster">ErdosRenyiCluster</a></li>
        
    
        <li class="main "><a href="#erdosrenyiclusterfix">ErdosRenyiClusterFix</a></li>
        
    
        <li class="main "><a href="#laplacians">Laplacians</a></li>
        
    
        <li class="main "><a href="#rootedtree">RootedTree</a></li>
        
    
        <li class="main "><a href="#akpw">akpw</a></li>
        
    
        <li class="main "><a href="#akpw_1">akpw!</a></li>
        
    
        <li class="main "><a href="#apr">apr</a></li>
        
    
        <li class="main "><a href="#augtreeprecon">augTreePrecon</a></li>
        
    
        <li class="main "><a href="#augtreesolver">augTreeSolver</a></li>
        
    
        <li class="main "><a href="#augmenttree">augmentTree</a></li>
        
    
        <li class="main "><a href="#backindices">backIndices</a></li>
        
    
        <li class="main "><a href="#biggestcomp">biggestComp</a></li>
        
    
        <li class="main "><a href="#cg">cg</a></li>
        
    
        <li class="main "><a href="#chimera">chimera</a></li>
        
    
        <li class="main "><a href="#compconductance">compConductance</a></li>
        
    
        <li class="main "><a href="#compdepth">compDepth</a></li>
        
    
        <li class="main "><a href="#compstretches">compStretches</a></li>
        
    
        <li class="main "><a href="#completebinarytree">completeBinaryTree</a></li>
        
    
        <li class="main "><a href="#completegraph">completeGraph</a></li>
        
    
        <li class="main "><a href="#components">components</a></li>
        
    
        <li class="main "><a href="#deg">deg</a></li>
        
    
        <li class="main "><a href="#diagmat">diagmat</a></li>
        
    
        <li class="main "><a href="#diredgevertexmat">dirEdgeVertexMat</a></li>
        
    
        <li class="main "><a href="#dumb">dumb</a></li>
        
    
        <li class="main "><a href="#edgevertexmat">edgeVertexMat</a></li>
        
    
        <li class="main "><a href="#findentries">findEntries</a></li>
        
    
        <li class="main "><a href="#floatgraph">floatGraph</a></li>
        
    
        <li class="main "><a href="#generalizednecklace">generalizedNecklace</a></li>
        
    
        <li class="main "><a href="#generalizedring">generalizedRing</a></li>
        
    
        <li class="main "><a href="#getobound">getObound</a></li>
        
    
        <li class="main "><a href="#getvolume">getVolume</a></li>
        
    
        <li class="main "><a href="#grid2">grid2</a></li>
        
    
        <li class="main "><a href="#grid2coords">grid2coords</a></li>
        
    
        <li class="main "><a href="#growngraph">grownGraph</a></li>
        
    
        <li class="main "><a href="#growngraphd">grownGraphD</a></li>
        
    
        <li class="main "><a href="#hypercube">hyperCube</a></li>
        
    
        <li class="main "><a href="#isconnected">isConnected</a></li>
        
    
        <li class="main "><a href="#joingraphs">joinGraphs</a></li>
        
    
        <li class="main "><a href="#kruskal">kruskal</a></li>
        
    
        <li class="main "><a href="#lap">lap</a></li>
        
    
        <li class="main "><a href="#lapchol">lapChol</a></li>
        
    
        <li class="main "><a href="#lapwrapsolver">lapWrapSolver</a></li>
        
    
        <li class="main "><a href="#localimprove">localImprove</a></li>
        
    
        <li class="main "><a href="#mapweight">mapweight</a></li>
        
    
        <li class="main "><a href="#mattotree">matToTree</a></li>
        
    
        <li class="main "><a href="#mattotreedepth">matToTreeDepth</a></li>
        
    
        <li class="main "><a href="#maxflow">maxflow</a></li>
        
    
        <li class="main "><a href="#nbri">nbri</a></li>
        
    
        <li class="main "><a href="#nbrs">nbrs</a></li>
        
    
        <li class="main "><a href="#pathfromparents">pathFromParents</a></li>
        
    
        <li class="main "><a href="#pathgraph">pathGraph</a></li>
        
    
        <li class="main "><a href="#pcg">pcg</a></li>
        
    
        <li class="main "><a href="#plotgraph">plotGraph</a></li>
        
    
        <li class="main "><a href="#prefattach">prefAttach</a></li>
        
    
        <li class="main "><a href="#prim">prim</a></li>
        
    
        <li class="main "><a href="#prn">prn</a></li>
        
    
        <li class="main "><a href="#productgraph">productGraph</a></li>
        
    
        <li class="main "><a href="#purerandomgraph">pureRandomGraph</a></li>
        
    
        <li class="main "><a href="#randgenring">randGenRing</a></li>
        
    
        <li class="main "><a href="#randmatching">randMatching</a></li>
        
    
        <li class="main "><a href="#randregular">randRegular</a></li>
        
    
        <li class="main "><a href="#randweight">randWeight</a></li>
        
    
        <li class="main "><a href="#randishkruskal">randishKruskal</a></li>
        
    
        <li class="main "><a href="#randishprim">randishPrim</a></li>
        
    
        <li class="main "><a href="#randperm">randperm</a></li>
        
    
        <li class="main "><a href="#readij">readIJ</a></li>
        
    
        <li class="main "><a href="#readijv">readIJV</a></li>
        
    
        <li class="main "><a href="#refinecut">refineCut</a></li>
        
    
        <li class="main "><a href="#ringgraph">ringGraph</a></li>
        
    
        <li class="main "><a href="#semiwtedchimera">semiWtedChimera</a></li>
        
    
        <li class="main "><a href="#setvalue">setValue</a></li>
        
    
        <li class="main "><a href="#shortintgraph">shortIntGraph</a></li>
        
    
        <li class="main "><a href="#shortestpathtree">shortestPathTree</a></li>
        
    
        <li class="main "><a href="#shortestpaths">shortestPaths</a></li>
        
    
        <li class="main "><a href="#spectralcoords">spectralCoords</a></li>
        
    
        <li class="main "><a href="#spectraldrawing">spectralDrawing</a></li>
        
    
        <li class="main "><a href="#subsampleedges">subsampleEdges</a></li>
        
    
        <li class="main "><a href="#tarjanstretch">tarjanStretch</a></li>
        
    
        <li class="main "><a href="#tounitvector">toUnitVector</a></li>
        
    
        <li class="main "><a href="#toposort">toposort</a></li>
        
    
        <li class="main "><a href="#twolift">twoLift</a></li>
        
    
        <li class="main "><a href="#uniformweight">uniformWeight</a></li>
        
    
        <li class="main "><a href="#uniformweight_1">uniformWeight!</a></li>
        
    
        <li class="main "><a href="#unweight">unweight</a></li>
        
    
        <li class="main "><a href="#unweight_1">unweight!</a></li>
        
    
        <li class="main "><a href="#vectocomps">vecToComps</a></li>
        
    
        <li class="main "><a href="#wdeg">wdeg</a></li>
        
    
        <li class="main "><a href="#weighti">weighti</a></li>
        
    
        <li class="main "><a href="#writeijv">writeIJV</a></li>
        
    
        <li class="main "><a href="#wtedchimera">wtedChimera</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h3 id="erdosrenyi">ErdosRenyi</h3>
<p>Generate a random graph on n vertices with m edges. The actual number of edges will probably be smaller, as we sample with replacement</p>
<pre><code class="julia">ErdosRenyi(n::Integer, m::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:337</p>
<h3 id="erdosrenyicluster">ErdosRenyiCluster</h3>
<p>Generate an ER graph with average degree k, and then return the largest component. Will probably have fewer than n vertices. If you want to add a tree to bring it back to n, try ErdosRenyiClusterFix.</p>
<pre><code class="julia">ErdosRenyiCluster(n::Integer, k::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:351</p>
<h3 id="erdosrenyiclusterfix">ErdosRenyiClusterFix</h3>
<p>Like an Erdos-Renyi cluster, but add back a tree so it has n vertices</p>
<pre><code class="julia">ErdosRenyiClusterFix(n::Integer, k::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:364</p>
<h3 id="laplacians">Laplacians</h3>
<p>A package for graph computations related to graph Laplacians</p>
<p>Graphs are represented by sparse adjacency matrices, etc.</p>
<h3 id="rootedtree">RootedTree</h3>
<p><strong>Summary:</strong></p>
<pre><code class="julia">type Laplacians.RootedTree{Tval,Tind} &lt;: Any
</code></pre>

<p><strong>Fields:</strong></p>
<pre><code class="julia">root     :: Tind
parent   :: Array{Tind,1}
children :: Array{Tind,1}
weights  :: Array{Tval,1}
numKids  :: Array{Tind,1}
kidsPtr  :: Array{Tind,1}
</code></pre>

<h3 id="akpw">akpw</h3>
<p>This is a wrapper for akpw!. It's slower, but won't modify the original graph. See akpw! documentation for more details.</p>
<pre><code class="julia">akpw(origMat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/akpwWeighted.jl:818</p>
<h3 id="akpw_1">akpw!</h3>
<p>Constructs a low stretch tree using the Alon, Karp, Peleg, West algorithm. This version (akpw! instead of akpw) modifies the graph slightly changing the edges weights, then changing them back, which may lead to floating point imprecisions. akpw! is faster (about 10-20%), but akpw doesn't have float imprecisions.</p>
<p>The function has a few options:</p>
<p>kind: default is :max, which regards each edge weight as the inverse of its length (just like kruskal). If this is   set to anything else (e.g. :min), it will regard edge weight as length</p>
<p>randomClusters: default is false. This means the partition function searches for the beginning of the next cluster   in node order, rather than randomly choosing nodes. If this is set to false, it will   randomly choose the next node. This slows down akpw, but may produce better stretch.</p>
<p>metisClustering: default is false. If this is set to false, the graph will be partitioned   each time by metis, rather than by the akpw partitioning method.</p>
<p>shuffleClusters: default is true. This preserves the "reshuffleClusters" method after each each graph is   partitioned into clusters. If set to false, the function will skip this step. May be faster   but have worse stretch.</p>
<p>exponentialX: default is true, where the funciton exp(sqrt(log(nVertices) * log(log(nVertices)))) is used for X.   If set fo false, the function log(nVertices+1)/log(2) will be used for X instead. </p>
<p>EXAMPLE:</p>
<p>[2, 1]  =  0.631273 [3, 1]  =  0.40103 [1, 2]  =  0.631273 [4, 2]  =  0.147018 [1, 3]  =  0.40103 [4, 3]  =  0.772661 [2, 4]  =  0.147018 [3, 4]  =  0.772661</p>
<pre><code>  |
  |
  V
</code></pre>

<p>[2, 1]  =  0.631273 [3, 1]  =  0.40103 [1, 2]  =  0.631273 [1, 3]  =  0.40103 [4, 3]  =  0.772661 [3, 4]  =  0.772661</p>
<pre><code class="julia">akpw!(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/akpwWeighted.jl:733</p>
<h3 id="apr">apr</h3>
<p>Computes an approximate page rank vector from a starting set s, an alpha and an epsilon The algorithm follows the Anderson,Chung,Lang paper and Dan Spielman's lecture notes</p>
<pre><code class="julia">apr{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1}, alpha::Float64, eps::Float64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/localClustering.jl:440</p>
<h3 id="augtreeprecon">augTreePrecon</h3>
<p>This is an augmented spanning tree preconditioner for diagonally dominant linear systems.  It takes as optional input a tree growing algorithm. The default is a randomized variant of Kruskal. It adds back 2sqrt(n) edges via augmentTree. With the right tree, it should never be too bad.</p>
<pre><code class="julia">augTreePrecon{Tv,Ti}(ddmat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/solvers.jl:188</p>
<h3 id="augtreesolver">augTreeSolver</h3>
<p>This is the solver that calls augTreePrecon</p>
<pre><code class="julia">augTreeSolver{Tv,Ti}(ddmat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/solvers.jl:210</p>
<h3 id="augmenttree">augmentTree</h3>
<p>Takes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It then adds back the k edges of highest stretch, and k edges sampled according to stretch</p>
<pre><code class="julia">augmentTree{Tv,Ti}(tree::SparseMatrixCSC{Tv,Ti}, mat::SparseMatrixCSC{Tv,Ti}, k::Ti)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/solvers.jl:138</p>
<h3 id="backindices">backIndices</h3>
<p>Same as the above, but now the graph is in adjacency list form </p>
<p>Computes the back indices in a graph in O(M+N). works if for every edge (u,v), (v,u) is also in the graph </p>
<pre><code class="julia">backIndices{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti})
backIndices{Tv1,Tv2}(G::Array{Array{Tuple{Tv1,Tv2},1},1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:35</p>
<h3 id="biggestcomp">biggestComp</h3>
<p>Return the biggest component in a graph, as a graph</p>
<pre><code class="julia">biggestComp(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:159</p>
<h3 id="cg">cg</h3>
<pre><code class="julia">cg(mat, b::Array{Float64,1})
cg(mat, b::Array{Float32,1})
cg(mat, b)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/pcg.jl:29</p>
<h3 id="chimera">chimera</h3>
<p>Builds the kth chimeric graph on n vertices. It does this by resetting the random number generator seed. It should captute the state of the generator before that and then return it, but it does not yet.</p>
<p>Builds a chimeric graph on n vertices. The components come from pureRandomGraph, connected by joinGraphs, productGraph and generalizedNecklace</p>
<pre><code class="julia">chimera(n::Integer)
chimera(n::Integer, k::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:515</p>
<h3 id="compconductance">compConductance</h3>
<p>Returns the quality of the cut for a given graph and a given cut set s.   the result will be |outgoing edges| / min(|vertices in set|, |N - vertices in set|)</p>
<pre><code class="julia">compConductance{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:136</p>
<h3 id="compdepth">compDepth</h3>
<pre><code class="julia">compDepth{Tv,Ti}(t::Laplacians.RootedTree{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/treeAlgs.jl:311</p>
<h3 id="compstretches">compStretches</h3>
<p>Compute the stretched of every edge in <code>mat</code> with respect to the tree <code>tree</code>. Returns the answer as a sparse matrix with the same nonzero structure as <code>mat</code>. Assumes that <code>mat</code> is symmetric. <code>tree</code> should be the adjacency matrix of a spanning tree.</p>
<pre><code class="julia">compStretches{Tv,Ti}(t::Laplacians.RootedTree{Tv,Ti}, mat::SparseMatrixCSC{Tv,Ti})
compStretches{Tv,Ti}(tree::SparseMatrixCSC{Tv,Ti}, mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/treeAlgs.jl:393</p>
<h3 id="completebinarytree">completeBinaryTree</h3>
<p>The complete binary tree on n vertices</p>
<pre><code class="julia">completeBinaryTree(n::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:139</p>
<h3 id="completegraph">completeGraph</h3>
<p>The complete graph</p>
<pre><code class="julia">completeGraph(n::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:17</p>
<h3 id="components">components</h3>
<p>Computes the connected components of a graph. Returns them as a vector of length equal to the number of vertices. The vector numbers the components from 1 through the maximum number. For example,</p>
<pre><code class="julia">gr = ErdosRenyi(10,11)
c = components(gr)

10-element Array{Int64,1}:
 1
 1
 1
 1
 2
 1
 1
 1
 3
 2
</code></pre>

<pre><code class="julia">components{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:65</p>
<h3 id="deg">deg</h3>
<pre><code class="julia">deg{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:11</p>
<h3 id="diagmat">diagmat</h3>
<p>Returns the diagonal matrix(as a sparse matrix) of a graph</p>
<pre><code class="julia">diagmat{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:205</p>
<h3 id="diredgevertexmat">dirEdgeVertexMat</h3>
<p>The signed edge-vertex adjacency matrix</p>
<pre><code class="julia">dirEdgeVertexMat(A::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/toposort.jl:49</p>
<h3 id="dumb">dumb</h3>
<pre><code>Modify a cluster by passing through all the vertices exactly once and 
adding/removing them based on the value of (Deg_external - Deg_Internal).
</code></pre>

<pre><code class="julia">dumb{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/cutHeuristics.jl:106</p>
<h3 id="edgevertexmat">edgeVertexMat</h3>
<p>The signed edge-vertex adjacency matrix</p>
<pre><code class="julia">edgeVertexMat(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:67</p>
<h3 id="findentries">findEntries</h3>
<p>Similar to findnz, but also returns 0 entries that have an edge in the sparse matrix </p>
<pre><code class="julia">findEntries{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:114</p>
<h3 id="floatgraph">floatGraph</h3>
<p>Convert the nonzero entries in a graph to Float64</p>
<pre><code class="julia">floatGraph(a::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:6</p>
<h3 id="generalizednecklace">generalizedNecklace</h3>
<p>Constructs a generalized necklace graph starting with two graphs A and H. The resulting new graph will be constructed by expanding each vertex in H to an instance of A. k random edges will be generated between components. Thus, the resulting graph may have weighted edges.</p>
<pre><code class="julia">generalizedNecklace{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, H::SparseMatrixCSC{Tv,Ti&lt;:Integer}, k::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:225</p>
<h3 id="generalizedring">generalizedRing</h3>
<p>A generalization of a ring graph. The vertices are integers modulo n. Two are connected if their difference is in gens. For example, </p>
<pre><code>generalizedRing(17, [1 5])
</code></pre>

<pre><code class="julia">generalizedRing(n::Int64, gens)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:38</p>
<h3 id="getobound">getObound</h3>
<p>Computes the number of edges leaving s </p>
<pre><code class="julia">getObound{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:167</p>
<h3 id="getvolume">getVolume</h3>
<p>Computes the volume of subset s in an unweighted graph G </p>
<pre><code class="julia">getVolume{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:149</p>
<h3 id="grid2">grid2</h3>
<p>An n-by-m grid graph.  iostropy is the weighting on edges in one direction.</p>
<pre><code class="julia">grid2(n::Int64)
grid2(n::Int64, m::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:159</p>
<h3 id="grid2coords">grid2coords</h3>
<p>Coordinates for plotting the vertices of the n-by-m grid graph</p>
<pre><code class="julia">grid2coords(n::Int64, m::Int64)
grid2coords(n)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:163</p>
<h3 id="growngraph">grownGraph</h3>
<p>Create a graph on n vertices. For each vertex, give it k edges to randomly chosen prior vertices. This is a variety of a preferential attachment graph.    </p>
<pre><code class="julia">grownGraph(n::Int64, k::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:202</p>
<h3 id="growngraphd">grownGraphD</h3>
<p>Like a grownGraph, but it forces the edges to all be distinct. It starts out with a k+1 clique on the first k vertices</p>
<pre><code class="julia">grownGraphD(n::Int64, k::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:234</p>
<h3 id="hypercube">hyperCube</h3>
<p>The d dimensional hypercube.  Has 2^d vertices</p>
<pre><code class="julia">hyperCube(d::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:125</p>
<h3 id="isconnected">isConnected</h3>
<p>Returns true if graph is connected.  Calls components.</p>
<pre><code class="julia">isConnected(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:113</p>
<h3 id="joingraphs">joinGraphs</h3>
<p>Create a disjoint union of graphs a and b,  and then put k random edges between them</p>
<pre><code class="julia">joinGraphs{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind}, b::SparseMatrixCSC{Tval,Tind}, k::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:111</p>
<h3 id="kruskal">kruskal</h3>
<p>Uses Kruskal's algorithm to compute a minimum (or maximum) spanning tree. Set kind=:max if you want the max spanning tree. It returns it a a graph</p>
<pre><code class="julia">kruskal{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:407</p>
<h3 id="lap">lap</h3>
<p>Create a Laplacian matrix from an adjacency matrix. We might want to do this differently, say by enforcing symmetry</p>
<pre><code class="julia">lap(a)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:12</p>
<h3 id="lapchol">lapChol</h3>
<h3 id="lapwrapsolver">lapWrapSolver</h3>
<p>Takes a solver for solving nonsingular sdd systems, and returns a solver for solving Laplacian systems. The optional args tol and maxits are not necessarily taken by all solvers.  But, if they are, one can pass them here</p>
<pre><code class="julia">lapWrapSolver(solver)
lapWrapSolver(solver, la::AbstractArray{T,N})
lapWrapSolver(solver, la::AbstractArray{T,N}, b)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/solvers.jl:108</p>
<h3 id="localimprove">localImprove</h3>
<p>localImprove{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, A::Array{Int64,1}; epsSigma=-1.0, err=1e-10, maxSize = max(G.n, G.m)</p>
<p>The LocalImprove function, from the Orrechia-Zhu paper. Given a graph and an initial set, finds a set of smaller conductance based on the starting set using a localized version of max-flow.</p>
<p>Small discussion: When adding in the neighbors of the initial component, if the resulting  conductance is worse than the initial one,  the algorithm will add more and more vertices until hitting a better conductance. However, if we fix a certain  maximum size for our component,  it might be the case that this new conductance will always be worse than what we had initially. Thus, if we run the algorithm with a small maxSize,  our initial conductance might be the best solution we can raech.</p>
<p>G is the given graph, A is the initial set  epsSigma is a measure of the quality of the returning set (the smaller the better). It's defaulted to volume(A) / volume(VA) err is the numerical error considered throughout the algorithm. It's defaulted to 1e-10 maxSize is the maximum allowed size for the flow graph at any iteration of the algorithm. It's defaulted to |V|</p>
<pre><code class="julia">localImprove{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, A::Array{Int64,1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/localClustering.jl:22</p>
<h3 id="mapweight">mapweight</h3>
<p>Create a new graph that is the same as the original, but with f applied to each nonzero entry of a. For example, to make the weight of every edge uniform in [0,1], we could write</p>
<pre><code class="julia">b = mapweight(a, x-&gt;rand(1)[1])
</code></pre>

<pre><code class="julia">mapweight{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind}, f)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:40</p>
<h3 id="mattotree">matToTree</h3>
<pre><code class="julia">matToTree{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
matToTree{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, root::Ti)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/treeAlgs.jl:32</p>
<h3 id="mattotreedepth">matToTreeDepth</h3>
<pre><code class="julia">matToTreeDepth{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
matToTreeDepth{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, root::Ti)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/treeAlgs.jl:98</p>
<h3 id="maxflow">maxflow</h3>
<p>implementation of Dinic's algorithm. computes the maximum flow and min-cut in G between s and t    we consider the adjacency matrix to be the capacity matrix </p>
<pre><code class="julia">maxflow{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Int64, t::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/flow.jl:7</p>
<h3 id="nbri">nbri</h3>
<pre><code class="julia">nbri{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti, i::Ti)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:12</p>
<h3 id="nbrs">nbrs</h3>
<pre><code class="julia">nbrs{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:14</p>
<h3 id="pathfromparents">pathFromParents</h3>
<pre><code class="julia">pathFromParents(parents, y)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:215</p>
<h3 id="pathgraph">pathGraph</h3>
<p>The path graph on n vertices</p>
<pre><code class="julia">pathGraph(n::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:8</p>
<h3 id="pcg">pcg</h3>
<pre><code class="julia">pcg(mat, b::Array{Float64,1}, pre)
pcg(mat, b::Array{Float32,1}, pre)
pcg(mat, b, pre)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/pcg.jl:42</p>
<h3 id="plotgraph">plotGraph</h3>
<p>Plots graph gr with coordinates (x,y)</p>
<pre><code class="julia">plotGraph(gr, x, y)
plotGraph(gr, x, y, color)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:129</p>
<h3 id="prefattach">prefAttach</h3>
<p>A preferential attachment graph in which each vertex has k edges to those that come before.  These are chosen with probability p to be from a random vertex, and with probability 1-p to come from the endpoint of a random edge. It begins with a k-clique on the first k+1 vertices.</p>
<pre><code class="julia">prefAttach(n::Int64, k::Int64, p::Float64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:258</p>
<h3 id="prim">prim</h3>
<pre><code class="julia">prim(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:438</p>
<h3 id="prn">prn</h3>
<p>prn{Tv, Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1}, phi::Float64, b::Int64)</p>
<p>The PageRank-Nibble cutting algorithm from the Anderson/Chung/Lang paper</p>
<p>s is a set of starting vertices, phi is a constant in (0, 1], and b is an integer in [1, [log m]]</p>
<p>phi is a bound on the quality of the conductance of the cut - the smaller the phi, the higher the quality.  b is used to handle precision throughout the algorithm - the higher the b, the greater the precision.</p>
<pre><code class="julia">prn{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1}, phi::Float64, b::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/localClustering.jl:374</p>
<h3 id="productgraph">productGraph</h3>
<p>The Cartesian product of two graphs.  When applied to two paths, it gives a grid.</p>
<pre><code class="julia">productGraph(a0::SparseMatrixCSC{Tv,Ti&lt;:Integer}, a1::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:58</p>
<h3 id="purerandomgraph">pureRandomGraph</h3>
<p>Generate a random graph with n vertices from one of our natural distributions</p>
<pre><code class="julia">pureRandomGraph(n::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:379</p>
<h3 id="randgenring">randGenRing</h3>
<p>A random generalized ring graph of degree k. Gens always contains 1, and the other k-1 edge types are chosen from an exponential distribution</p>
<pre><code class="julia">randGenRing(n::Int64, k::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:62</p>
<h3 id="randmatching">randMatching</h3>
<p>A random matching on n vertices</p>
<pre><code class="julia">randMatching(n::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:174</p>
<h3 id="randregular">randRegular</h3>
<p>A sum of k random matchings on n vertices</p>
<pre><code class="julia">randRegular(n::Int64, k::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:187</p>
<h3 id="randweight">randWeight</h3>
<p>Applies one of a number of random weighting schemes to the edges of the graph</p>
<pre><code class="julia">randWeight(a)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:535</p>
<h3 id="randishkruskal">randishKruskal</h3>
<pre><code class="julia">randishKruskal{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/randTrees.jl:10</p>
<h3 id="randishprim">randishPrim</h3>
<pre><code class="julia">randishPrim{Tval,Tind}(mat::SparseMatrixCSC{Tval,Tind})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/randTrees.jl:47</p>
<h3 id="randperm">randperm</h3>
<pre><code class="rst">..  randperm([rng,] n)

Construct a random permutation of length ``n``. The optional ``rng`` argument
specifies a random number generator, see :ref:`Random Numbers &lt;random-numbers&gt;`.
</code></pre>

<p>Randomly permutes the vertex indices</p>
<pre><code class="julia">randperm(r::AbstractRNG, n::Integer)
randperm(n::Integer)
randperm(mat::AbstractArray{T,2})
randperm(f::Expr)
</code></pre>

<p>at random.jl:1341</p>
<h3 id="readij">readIJ</h3>
<p>To read a simple edge list, each line being an (i, j) pair</p>
<pre><code class="julia">readIJ(filename::AbstractString)
readIJ(filename::AbstractString, sep)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/IO.jl:4</p>
<h3 id="readijv">readIJV</h3>
<p>To read a simple edge list, each line being an (i, j, v) pair. The parens should not be there in the format, just commas separating. To generate this format in Matlab, you just need to be careful to write the vertex indices with sufficient precision.  For example, you can do this</p>
<pre><code>&gt;&gt; [ai,aj,av] = find(triu(a));
&gt;&gt; dlmwrite('graph.txt',[ai,aj,av],'precision',9);
</code></pre>

<pre><code class="julia">readIJV(filename::AbstractString)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/IO.jl:25</p>
<h3 id="refinecut">refineCut</h3>
<pre><code>Modifies a cluster by adding or removing vertices by picking at each step 
the vertex that has the maximum value of (Deg_external - Deg_Internal).
Each vertex can be added in/removed only once.
</code></pre>

<pre><code class="julia">refineCut{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Array{Int64,1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/cutHeuristics.jl:9</p>
<h3 id="ringgraph">ringGraph</h3>
<p>The simple ring on n vertices</p>
<pre><code class="julia">ringGraph(n::Int64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:23</p>
<h3 id="semiwtedchimera">semiWtedChimera</h3>
<p>A Chimera graph with some weights.  The weights just appear when graphs are combined. For more interesting weights, use <code>wtedChimera</code></p>
<pre><code class="julia">semiWtedChimera(n::Integer)
semiWtedChimera(n::Integer, k::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:442</p>
<h3 id="setvalue">setValue</h3>
<p>Sets the value of a certain edge in a sparse graph; value can be 0 without the edges dissapearing </p>
<pre><code class="julia">setValue{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti, i::Ti, a::Tv)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:29</p>
<h3 id="shortintgraph">shortIntGraph</h3>
<p>Convert the indices in a graph to 32-bit ints.  This takes less storage, but does not speed up much</p>
<pre><code class="julia">shortIntGraph(a::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:3</p>
<h3 id="shortestpathtree">shortestPathTree</h3>
<p>Computes the shortest path tree, and returns it as a sparse matrix. Treats edge weights as reciprocals of lengths. For example:</p>
<pre><code class="julia">a = [0 2 1; 2 0 3; 1 3 0]
tr = full(shortestPathTree(sparse(a),1))

3x3 Array{Float64,2}:
 0.0  2.0  0.0
 2.0  0.0  3.0
 0.0  3.0  0.0
</code></pre>

<pre><code class="julia">shortestPathTree(a, start)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:239</p>
<h3 id="shortestpaths">shortestPaths</h3>
<p>Computes the lenghts of shortest paths from <code>start</code>. Returns both a vector of the lenghts, and the parent array in the shortest path tree.</p>
<p>This algorithm treats edge weights as reciprocals of distances. DOC BETTER</p>
<pre><code class="julia">shortestPaths{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, start::Ti)
shortestPaths{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:175</p>
<h3 id="spectralcoords">spectralCoords</h3>
<p>Computes the spectral coordinates of a graph</p>
<pre><code class="julia">spectralCoords(a)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:174</p>
<h3 id="spectraldrawing">spectralDrawing</h3>
<p>Computes spectral coordinates, and then uses plotGraph to draw</p>
<pre><code class="julia">spectralDrawing(a)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:166</p>
<h3 id="subsampleedges">subsampleEdges</h3>
<p>Create a new graph from the old, but keeping edge edge with probability <code>p</code></p>
<pre><code class="julia">subsampleEdges(a::SparseMatrixCSC{Float64,Int64}, p::Float64)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:76</p>
<h3 id="tarjanstretch">tarjanStretch</h3>
<pre><code class="julia">tarjanStretch{Tv,Ti}(t::Laplacians.RootedTree{Tv,Ti}, mat::SparseMatrixCSC{Tv,Ti}, depth::Array{Tv,1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/treeAlgs.jl:334</p>
<h3 id="tounitvector">toUnitVector</h3>
<p>Creates a unit vector of length n from a given set of integers, with weights based on the number of occurences</p>
<pre><code class="julia">toUnitVector(a::Array{Int64,1}, n)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:183</p>
<h3 id="toposort">toposort</h3>
<pre><code class="julia">toposort{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/toposort.jl:13</p>
<h3 id="twolift">twoLift</h3>
<p>Creats a 2-lift of a.  <code>flip</code> is a boolean indicating which edges cross</p>
<pre><code class="julia">twoLift(a)
twoLift(a, flip::AbstractArray{Bool,1})
twoLift(a, k::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:99</p>
<h3 id="uniformweight">uniformWeight</h3>
<p>Put a uniform [0,1] weight on every edge.  This is an example of how to use mapweight.</p>
<pre><code class="julia">uniformWeight{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:49</p>
<h3 id="uniformweight_1">uniformWeight!</h3>
<p>Set the weight of every edge to 1</p>
<pre><code class="julia">uniformWeight!(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:53</p>
<h3 id="unweight">unweight</h3>
<p>Create a new graph in that is the same as the original, but with all edge weights 1</p>
<pre><code class="julia">unweight{Tval,Tind}(ain::SparseMatrixCSC{Tval,Tind})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:16</p>
<h3 id="unweight_1">unweight!</h3>
<p>Change the weight of every edge in a to 1</p>
<pre><code class="julia">unweight!{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphOps.jl:26</p>
<h3 id="vectocomps">vecToComps</h3>
<p>This turns a component vector, like that generated by components, into an array of arrays of indices of vertices in each component.  For example,</p>
<pre><code class="julia">comps = vecToComps(c)

3-element Array{Array{Int64,1},1}:
 [1,2,3,4,6,7,8]
 [5,10]
 [9]
</code></pre>

<pre><code class="julia">vecToComps{Ti}(compvec::Array{Ti,1})
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphAlgs.jl:136</p>
<h3 id="wdeg">wdeg</h3>
<p>Finds the weighted degree of a vertex in the graph </p>
<pre><code class="julia">wdeg{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:19</p>
<h3 id="weighti">weighti</h3>
<pre><code class="julia">weighti{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti, i::Ti)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphUtils.jl:13</p>
<h3 id="writeijv">writeIJV</h3>
<p>Writes the upper portion of a matrix in ijv format, one row for each edge, separated by commas.  Only writes the upper triangular portion. The result can be read from Matlab like this:</p>
<pre><code>&gt;&gt; dl = dlmread('graph.txt');
&gt;&gt; a = sparse(dl(:,1),dl(:,2),dl(:,3));
&gt;&gt; n = max(size(a))
&gt;&gt; a(n,n) = 0;
&gt;&gt; a = a + a';
</code></pre>

<pre><code class="julia">writeIJV(filename::AbstractString, mat)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/IO.jl:52</p>
<h3 id="wtedchimera">wtedChimera</h3>
<p>Builds the kth wted chimeric graph on n vertices. It does this by resetting the random number generator seed. It should captute the state of the generator before that and then return it, but it does not yet.</p>
<p>Generate a chimera, and then apply a random weighting scheme</p>
<pre><code class="julia">wtedChimera(n::Integer)
wtedChimera(n::Integer, k::Integer)
</code></pre>

<p>at /Users/serbanstan/git/Laplacians.jl/src/graphGenerators.jl:607</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
        <script src="../mathjaxhelper.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
